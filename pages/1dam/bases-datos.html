<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Apuntes completos de Bases de Datos para 1¬∫ DAM - SQL, MySQL, dise√±o de BD, normalizaci√≥n y consultas.">
    <meta name="keywords" content="SQL, MySQL, bases de datos, DAM, consultas, normalizaci√≥n, joins">
    <title>Bases de Datos - 1¬∫ DAM | CodeDAM</title>
    <link rel="stylesheet" href="../../css/styles.css">
    <link rel="stylesheet" href="../../css/dark-mode.css">
    <link rel="stylesheet" href="../../css/content-pages.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <!-- Prism.js for Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
</head>
<body>
    <!-- Header -->
<header class="header" id="header">
    <nav class="navbar-container">
        <a href="../../index.html" class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                    <rect x="5" y="5" width="30" height="30" rx="8" fill="url(#logoGradient)" />
                    <path d="M15 12 L15 28 M20 12 L20 28 M25 12 L25 28" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                </svg>
            </div>
            <div class="logo-text">
                <span class="logo-code">Code</span><span class="logo-dam">DAM</span>
            </div>
        </a>
        
        <ul class="navbar-menu">
            <li><a href="../../index.html" class="nav-link">Inicio</a></li>
            <li class="dropdown">
                <button class="dropbtn nav-link">1¬∫ DAM <span class="arrow">‚ñº</span></button>
                <div class="dropdown-content">
                    <a href="./programacion.html">
                        <span class="dropdown-icon">üíª</span>
                        <div>
                            <div class="dropdown-title">Programaci√≥n</div>
                            <div class="dropdown-subtitle">Java & POO</div>
                        </div>
                    </a>
                    <a href="./bases-datos.html">
                        <span class="dropdown-icon">üóÑÔ∏è</span>
                        <div>
                            <div class="dropdown-title">Bases de Datos</div>
                            <div class="dropdown-subtitle">SQL & MySQL</div>
                        </div>
                    </a>
                    <a href="./lenguajes-marcas.html">
                        <span class="dropdown-icon">üåê</span>
                        <div>
                            <div class="dropdown-title">Lenguajes de Marcas</div>
                            <div class="dropdown-subtitle">HTML, CSS, XML</div>
                        </div>
                    </a>
                    <a href="./entornos-desarrollo.html">
                        <span class="dropdown-icon">‚öôÔ∏è</span>
                        <div>
                            <div class="dropdown-title">Entornos de Desarrollo</div>
                            <div class="dropdown-subtitle">Git & IDEs</div>
                        </div>
                    </a>
                    <a href="./sistemas-informaticos.html">
                        <span class="dropdown-icon">üíæ</span>
                        <div>
                            <div class="dropdown-title">Sistemas Inform√°ticos</div>
                            <div class="dropdown-subtitle">Windows & Linux</div>
                        </div>
                    </a>
                </div>
            </li>
            <li class="dropdown">
                <button class="dropbtn nav-link">2¬∫ DAM <span class="arrow">‚ñº</span></button>
                <div class="dropdown-content">
                    <a href="../2dam/acceso-datos.html">
                        <span class="dropdown-icon">üìä</span>
                        <div>
                            <div class="dropdown-title">Acceso a Datos</div>
                            <div class="dropdown-subtitle">JDBC & Hibernate</div>
                        </div>
                    </a>
                    <a href="../2dam/desarrollo-interfaces.html">
                        <span class="dropdown-icon">üé®</span>
                        <div>
                            <div class="dropdown-title">Desarrollo de Interfaces</div>
                            <div class="dropdown-subtitle">JavaFX & UI/UX</div>
                        </div>
                    </a>
                    <a href="../2dam/programacion-multimedia.html">
                        <span class="dropdown-icon">üì±</span>
                        <div>
                            <div class="dropdown-title">Programaci√≥n Multimedia</div>
                            <div class="dropdown-subtitle">Android & Kotlin</div>
                        </div>
                    </a>
                    <a href="../2dam/programacion-servicios.html">
                        <span class="dropdown-icon">üåê</span>
                        <div>
                            <div class="dropdown-title">Programaci√≥n de Servicios</div>
                            <div class="dropdown-subtitle">Spring Boot & APIs</div>
                        </div>
                    </a>
                    <a href="../2dam/sistemas-gestion.html">
                        <span class="dropdown-icon">üè¢</span>
                        <div>
                            <div class="dropdown-title">Sistemas de Gesti√≥n</div>
                            <div class="dropdown-subtitle">ERP & Odoo</div>
                        </div>
                    </a>
                </div>
            </li>
            <li class="dropdown">
                <button class="dropbtn nav-link">Cursos Especiales <span class="arrow">‚ñº</span></button>
                <div class="dropdown-content">
                    <a href="../ingles/index.html">
                        <span class="dropdown-icon">üåç</span>
                        <div>
                            <div class="dropdown-title">Ingl√©s T√©cnico</div>
                            <div class="dropdown-subtitle">Tech English</div>
                        </div>
                    </a>
                </div>
            </li>
        </ul>

        <!-- Dark Mode Toggle -->
        <button class="theme-toggle" id="themeToggle" aria-label="Cambiar tema">
            <svg class="sun-icon" width="20" height="20" viewBox="0 0 20 20" fill="none">
                <circle cx="10" cy="10" r="4" stroke="currentColor" stroke-width="2"/>
                <path d="M10 2V4M10 16V18M18 10H16M4 10H2M15.657 4.343L14.243 5.757M5.757 14.243L4.343 15.657M15.657 15.657L14.243 14.243M5.757 5.757L4.343 4.343" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <svg class="moon-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" style="display: none;">
                <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>

        <!-- Mobile Menu Button -->
        <button class="mobile-menu-btn" id="mobileMenuBtn">
            <span></span>
            <span></span>
            <span></span>
        </button>
    </nav>
</header>


    <section class="page-header">
        <div class="container">
            <div class="breadcrumb">
                <a href="../../index.html">Inicio</a>
                <span>‚Üí</span>
                <a href="../../index.html#1dam">1¬∫ DAM</a>
                <span>‚Üí</span>
                <span>Bases de Datos</span>
            </div>
            <h1 class="page-title">Bases de Datos</h1>
            <p class="page-subtitle">SQL, MySQL y Dise√±o de Bases de Datos Relacionales</p>
        </div>
    </section>

    <main class="container">
        <div class="content-wrapper">
            <nav class="toc">
                <h3>√çndice de Contenidos</h3>
                <ul></ul>
            </nav>

            <div class="content-main">
                <!-- Introducci√≥n -->
                <section class="content-section">
                    <h2>Introducci√≥n a las Bases de Datos</h2>
                    <p>Las bases de datos son fundamentales en el desarrollo de software moderno. Desde aplicaciones m√≥viles hasta sistemas empresariales, pr√°cticamente todo software almacena y gestiona informaci√≥n.</p>

                    <h3>¬øQu√© es una Base de Datos?</h3>
                    <p>Una <strong>base de datos</strong> es un conjunto organizado de informaci√≥n estructurada que se almacena electr√≥nicamente y puede ser accedida, gestionada y actualizada de forma eficiente.</p>

                    <div class="note-box">
                        <p><strong>Ejemplo del mundo real:</strong> Imagina una biblioteca. Los ficheros tradicionales ser√≠an como buscar libro por libro. Una base de datos ser√≠a como tener un cat√°logo digital donde puedes buscar instant√°neamente por t√≠tulo, autor, tema, ISBN, etc.</p>
                    </div>

                    <h3>¬øPor Qu√© Usar Bases de Datos?</h3>
                    <ul>
                        <li><strong>Organizaci√≥n:</strong> Los datos est√°n estructurados y son f√°ciles de encontrar</li>
                        <li><strong>Eficiencia:</strong> B√∫squedas r√°pidas incluso con millones de registros</li>
                        <li><strong>Integridad:</strong> Reglas que aseguran que los datos sean correctos y consistentes</li>
                        <li><strong>Seguridad:</strong> Control de qui√©n puede ver/modificar qu√© datos</li>
                        <li><strong>Concurrencia:</strong> M√∫ltiples usuarios pueden acceder simult√°neamente</li>
                        <li><strong>Respaldo y Recuperaci√≥n:</strong> F√°cil hacer copias de seguridad</li>
                        <li><strong>Reducci√≥n de Redundancia:</strong> No duplicar la misma informaci√≥n</li>
                    </ul>

                    <h3>Tipos de Bases de Datos</h3>

                    <h4>Bases de Datos Relacionales (SQL)</h4>
                    <p>Organizan los datos en <strong>tablas</strong> (filas y columnas) relacionadas entre s√≠. Son las m√°s usadas.</p>
                    <ul>
                        <li><strong>MySQL:</strong> Popular, gratuito, ideal para web</li>
                        <li><strong>PostgreSQL:</strong> Potente, c√≥digo abierto, caracter√≠sticas avanzadas</li>
                        <li><strong>Oracle:</strong> Usado en grandes empresas</li>
                        <li><strong>SQL Server:</strong> De Microsoft</li>
                        <li><strong>SQLite:</strong> Ligero, usado en m√≥viles y aplicaciones peque√±as</li>
                    </ul>

                    <div class="code-block">
                        <code>-- Ejemplo de tabla relacional: CLIENTES
                        +------------+------------------+----------------------+
                        | id_cliente | nombre           | email                |
                        +------------+------------------+----------------------+
                        | 1          | Ana Garc√≠a       | ana@email.com        |
                        | 2          | Juan P√©rez       | juan@email.com       |
                        | 3          | Mar√≠a L√≥pez      | maria@email.com      |
                        +------------+------------------+----------------------+
                        </code>
                    </div>

                    <h4>Bases de Datos No Relacionales (NoSQL)</h4>
                    <p>Almacenan datos en formatos diferentes (documentos, clave-valor, grafos). √ötiles para big data y aplicaciones en tiempo real.</p>
                    <ul>
                        <li><strong>MongoDB:</strong> Documentos JSON</li>
                        <li><strong>Redis:</strong> Clave-valor (muy r√°pido)</li>
                        <li><strong>Cassandra:</strong> Para datos masivos distribuidos</li>
                        <li><strong>Neo4j:</strong> Bases de datos de grafos</li>
                    </ul>

                    <div class="note-box">
                        <p><strong>En 1¬∫ DAM nos enfocamos en bases de datos relacionales (SQL).</strong> Son las m√°s demandadas en el mercado laboral y base para entender cualquier sistema de gesti√≥n de datos.</p>
                    </div>

                    <h3>Conceptos Fundamentales</h3>

                    <h4>Tabla</h4>
                    <p>Conjunto de datos organizados en <strong>filas</strong> (registros) y <strong>columnas</strong> (campos). Cada tabla representa una entidad (Clientes, Productos, Pedidos, etc.).</p>

                    <h4>Registro (Fila)</h4>
                    <p>Una entrada individual en una tabla. Por ejemplo, un cliente espec√≠fico.</p>

                    <h4>Campo (Columna)</h4>
                    <p>Un atributo de los datos. Por ejemplo: nombre, email, tel√©fono.</p>

                    <h4>Clave Primaria (Primary Key - PK)</h4>
                    <p>Campo que identifica <strong>√∫nicamente</strong> cada registro. No puede repetirse ni ser NULL.</p>

                    <div class="code-block">
                        <code>-- id_cliente es la clave primaria
                    CREATE TABLE clientes (
                        id_cliente INT PRIMARY KEY AUTO_INCREMENT,  -- Clave primaria
                        nombre VARCHAR(100),
                        email VARCHAR(100)
                    );</code>
                    </div>

                    <h4>Clave For√°nea (Foreign Key - FK)</h4>
                    <p>Campo que hace referencia a la clave primaria de otra tabla. Establece relaciones entre tablas.</p>

                    <div class="code-block">
                        <code>-- id_cliente en pedidos es clave for√°nea que referencia a clientes
                        CREATE TABLE pedidos (
                            id_pedido INT PRIMARY KEY AUTO_INCREMENT,
                            id_cliente INT,  -- Clave for√°nea
                            fecha DATE,
                            FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
                        );</code>
                    </div>

                    <h3>SGBD (Sistema Gestor de Bases de Datos)</h3>
                    <p>Software que permite crear, gestionar y manipular bases de datos. En este curso usaremos <strong>MySQL</strong>.</p>

                    <h4>¬øPor qu√© MySQL?</h4>
                    <ul>
                        <li>Gratuito y c√≥digo abierto</li>
                        <li>F√°cil de instalar y usar</li>
                        <li>Muy usado en la industria (WordPress, Facebook, Twitter...)</li>
                        <li>Gran comunidad y documentaci√≥n</li>
                        <li>Compatible con la mayor√≠a de lenguajes (Java, PHP, Python, etc.)</li>
                        <li>Buen rendimiento para aplicaciones web</li>
                    </ul>

                    <h3>SQL (Structured Query Language)</h3>
                    <p>Lenguaje est√°ndar para comunicarse con bases de datos relacionales. SQL permite:</p>
                    <ul>
                        <li><strong>DDL (Data Definition Language):</strong> Definir estructura (CREATE, ALTER, DROP)</li>
                        <li><strong>DML (Data Manipulation Language):</strong> Manipular datos (SELECT, INSERT, UPDATE, DELETE)</li>
                        <li><strong>DCL (Data Control Language):</strong> Control de acceso (GRANT, REVOKE)</li>
                        <li><strong>TCL (Transaction Control Language):</strong> Transacciones (COMMIT, ROLLBACK)</li>
                    </ul>

                    <div class="warning-box">
                        <p><strong>Importante:</strong> SQL no es case-sensitive (SELECT = select = SeLeCt), pero por convenci√≥n se escriben las palabras clave en MAY√öSCULAS para mejor legibilidad.</p>
                    </div>

                    <div class="note-box">
                        <p><strong>Trucos Pro - Introducci√≥n:</strong></p>
                        <ul>
                            <li>Instala MySQL Workbench (interfaz gr√°fica oficial)</li>
                            <li>Tambi√©n puedes usar phpMyAdmin (web) o DBeaver (multiplataforma)</li>
                            <li>Practica con bases de datos de ejemplo (sakila, world)</li>
                            <li>Usa comentarios en SQL: <code>-- comentario de l√≠nea</code> o <code>/* comentario multi-l√≠nea */</code></li>
                        </ul>
                    </div>
                </section>

                <!-- Modelo Entidad-Relaci√≥n -->
                <section class="content-section">
                    <h2>Modelo Entidad-Relaci√≥n (E-R)</h2>
                    <p>El modelo E-R es una herramienta de dise√±o conceptual que ayuda a visualizar y planificar la estructura de una base de datos ANTES de implementarla.</p>

                    <h3>Componentes del Modelo E-R</h3>

                    <h4>1. Entidades</h4>
                    <p>Objetos o conceptos del mundo real sobre los que queremos almacenar informaci√≥n. Se representan con <strong>rect√°ngulos</strong>.</p>

                    <div class="note-box">
                        <p><strong>Ejemplos de entidades:</strong> Cliente, Producto, Pedido, Empleado, Curso, Estudiante, Libro, Autor...</p>
                    </div>

                    <h4>2. Atributos</h4>
                    <p>Caracter√≠sticas o propiedades de las entidades. Se representan con <strong>√≥valos</strong>.</p>

                    <div class="code-block">
                        <code>Entidad: CLIENTE
                        Atributos:
                        - id_cliente (identificador √∫nico)
                        - nombre
                        - apellidos
                        - email
                        - tel√©fono
                        - fecha_registro
                        - direcci√≥n</code>
                    </div>

                    <h5>Tipos de Atributos:</h5>
                    <ul>
                        <li><strong>Simples:</strong> No se pueden dividir (nombre, edad)</li>
                        <li><strong>Compuestos:</strong> Se pueden dividir (direcci√≥n = calle + ciudad + c√≥digo postal)</li>
                        <li><strong>√önicos:</strong> Identifican a la entidad (DNI, email)</li>
                        <li><strong>Multivaluados:</strong> Pueden tener varios valores (tel√©fonos de contacto)</li>
                        <li><strong>Derivados:</strong> Se calculan a partir de otros (edad se calcula desde fecha_nacimiento)</li>
                    </ul>

                    <h4>3. Relaciones</h4>
                    <p>V√≠nculos o asociaciones entre entidades. Se representan con <strong>rombos</strong>.</p>

                    <div class="code-block">
                        <code>CLIENTE ---realiza---> PEDIDO
                        PRODUCTO ---pertenece_a---> CATEGOR√çA
                        ESTUDIANTE ---cursa---> ASIGNATURA</code>
                    </div>

                    <h3>Cardinalidad de Relaciones</h3>
                    <p>Define cu√°ntas instancias de una entidad se pueden relacionar con instancias de otra.</p>

                    <h4>1:1 (Uno a Uno)</h4>
                    <p>Un registro de A se relaciona con exactamente un registro de B, y viceversa.</p>

                    <div class="code-block">
                        <code>Ejemplo: PERSONA (1) ---tiene---> (1) PASAPORTE

                        - Una persona tiene un √∫nico pasaporte
                        - Un pasaporte pertenece a una √∫nica persona

                        CREATE TABLE personas (
                            id_persona INT PRIMARY KEY,
                            nombre VARCHAR(100),
                            dni VARCHAR(9) UNIQUE
                        );

                        CREATE TABLE pasaportes (
                            id_pasaporte INT PRIMARY KEY,
                            numero_pasaporte VARCHAR(20),
                            fecha_expedicion DATE,
                            id_persona INT UNIQUE,  -- UNIQUE asegura la relaci√≥n 1:1
                            FOREIGN KEY (id_persona) REFERENCES personas(id_persona)
                        );</code>
                    </div>

                    <h4>1:N (Uno a Muchos) - M√ÅS COM√öN</h4>
                    <p>Un registro de A se puede relacionar con varios registros de B, pero un registro de B solo se relaciona con uno de A.</p>

                    <div class="code-block">
                        <code>Ejemplo: CLIENTE (1) ---realiza---> (N) PEDIDOS

                        - Un cliente puede hacer muchos pedidos
                        - Cada pedido pertenece a un solo cliente

                        CREATE TABLE clientes (
                            id_cliente INT PRIMARY KEY AUTO_INCREMENT,
                            nombre VARCHAR(100),
                            email VARCHAR(100)
                        );

                        CREATE TABLE pedidos (
                            id_pedido INT PRIMARY KEY AUTO_INCREMENT,
                            fecha DATE,
                            total DECIMAL(10,2),
                            id_cliente INT,  -- La FK va en el lado "muchos"
                            FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
                        );

                        -- Otros ejemplos 1:N:
                        -- DEPARTAMENTO (1) --- (N) EMPLEADOS
                        -- CATEGOR√çA (1) --- (N) PRODUCTOS
                        -- AUTOR (1) --- (N) LIBROS</code>
                    </div>

                    <h4>N:M (Muchos a Muchos)</h4>
                    <p>Varios registros de A se relacionan con varios de B, y viceversa. Requiere una <strong>tabla intermedia</strong>.</p>

                    <div class="code-block">
                        <code>Ejemplo: ESTUDIANTE (N) ---cursa---> (M) ASIGNATURA

                        - Un estudiante puede cursar muchas asignaturas
                        - Una asignatura puede tener muchos estudiantes

                        -- SOLUCI√ìN: Tabla intermedia "matriculas"

                        CREATE TABLE estudiantes (
                            id_estudiante INT PRIMARY KEY AUTO_INCREMENT,
                            nombre VARCHAR(100),
                            email VARCHAR(100)
                        );

                        CREATE TABLE asignaturas (
                            id_asignatura INT PRIMARY KEY AUTO_INCREMENT,
                            nombre VARCHAR(100),
                            creditos INT
                        );

                        -- Tabla intermedia (convierte N:M en dos relaciones 1:N)
                        CREATE TABLE matriculas (
                            id_matricula INT PRIMARY KEY AUTO_INCREMENT,
                            id_estudiante INT,
                            id_asignatura INT,
                            fecha_matricula DATE,
                            nota DECIMAL(4,2),
                            FOREIGN KEY (id_estudiante) REFERENCES estudiantes(id_estudiante),
                            FOREIGN KEY (id_asignatura) REFERENCES asignaturas(id_asignatura),
                            UNIQUE(id_estudiante, id_asignatura)  -- Un estudiante no puede matricularse 2 veces en la misma asignatura
                        );

                        -- Otros ejemplos N:M:
                        -- PRODUCTO (N) --- (M) PEDIDO ‚Üí tabla "detalle_pedido"
                        -- ACTOR (N) --- (M) PEL√çCULA ‚Üí tabla "reparto"
                        -- M√âDICO (N) --- (M) PACIENTE ‚Üí tabla "citas"</code>
                    </div>

                    <h3>Ejemplo Completo: Sistema de Tienda Online</h3>

                    <div class="code-block">
                        <code>-- DISE√ëO CONCEPTUAL (E-R):
                        --
                        -- Entidades: CLIENTE, PRODUCTO, PEDIDO, CATEGOR√çA
                        --
                        -- Relaciones:
                        -- - CLIENTE (1) ---realiza---> (N) PEDIDO
                        -- - CATEGOR√çA (1) ---contiene---> (N) PRODUCTO
                        -- - PRODUCTO (N) ---aparece_en---> (M) PEDIDO  (tabla intermedia: detalle_pedido)

                        -- IMPLEMENTACI√ìN EN SQL:

                        -- 1. Tabla independiente (sin FK)
                        CREATE TABLE categorias (
                            id_categoria INT PRIMARY KEY AUTO_INCREMENT,
                            nombre VARCHAR(50) NOT NULL,
                            descripcion TEXT
                        );

                        -- 2. Tabla con FK a categor√≠as
                        CREATE TABLE productos (
                            id_producto INT PRIMARY KEY AUTO_INCREMENT,
                            nombre VARCHAR(200) NOT NULL,
                            descripcion TEXT,
                            precio DECIMAL(10,2) NOT NULL,
                            stock INT DEFAULT 0,
                            id_categoria INT,
                            FOREIGN KEY (id_categoria) REFERENCES categorias(id_categoria)
                        );

                        -- 3. Tabla independiente
                        CREATE TABLE clientes (
                            id_cliente INT PRIMARY KEY AUTO_INCREMENT,
                            nombre VARCHAR(100) NOT NULL,
                            apellidos VARCHAR(100),
                            email VARCHAR(100) UNIQUE,
                            telefono VARCHAR(15),
                            direccion VARCHAR(255),
                            fecha_registro DATETIME DEFAULT CURRENT_TIMESTAMP
                        );

                        -- 4. Tabla con FK a clientes
                        CREATE TABLE pedidos (
                            id_pedido INT PRIMARY KEY AUTO_INCREMENT,
                            id_cliente INT NOT NULL,
                            fecha_pedido DATETIME DEFAULT CURRENT_TIMESTAMP,
                            estado ENUM('pendiente', 'procesando', 'enviado', 'entregado', 'cancelado') DEFAULT 'pendiente',
                            total DECIMAL(10,2),
                            FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
                        );

                        -- 5. Tabla intermedia (N:M entre productos y pedidos)
                        CREATE TABLE detalle_pedido (
                            id_detalle INT PRIMARY KEY AUTO_INCREMENT,
                            id_pedido INT,
                            id_producto INT,
                            cantidad INT NOT NULL,
                            precio_unitario DECIMAL(10,2) NOT NULL,
                            subtotal DECIMAL(10,2),
                            FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido),
                            FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
                        );</code>
                    </div>

                    <div class="warning-box">
                        <p><strong>Errores Comunes en Dise√±o E-R:</strong></p>
                        <ul>
                            <li>No identificar correctamente las relaciones N:M (olvidar la tabla intermedia)</li>
                            <li>Crear demasiadas tablas (sobre-normalizaci√≥n)</li>
                            <li>No definir claves primarias</li>
                            <li>Usar nombres gen√©ricos (tabla "datos" con columna "valor")</li>
                            <li>Mezclar entidades con relaciones</li>
                        </ul>
                    </div>

                    <div class="note-box">
                        <p><strong>Trucos Pro - Modelo E-R:</strong></p>
                        <ul>
                            <li>Dibuja el diagrama en papel antes de escribir SQL</li>
                            <li>Usa herramientas: MySQL Workbench, draw.io, Lucidchart</li>
                            <li>Preg√∫ntate: "¬øCu√°ntos X puede tener un Y?" para determinar cardinalidad</li>
                            <li>Nombres de tablas en plural (clientes, productos) o singular seg√∫n convenci√≥n del proyecto</li>
                            <li>Nombres de FK claros: id_cliente, no solo "cliente" o "id"</li>
                        </ul>
                    </div>
                </section>

                <!-- SQL B√°sico -->
                <section class="content-section">
                    <h2>SQL B√°sico - Fundamentos</h2>
                    <p>SQL (Structured Query Language) es el lenguaje universal para trabajar con bases de datos relacionales. Vamos a aprender los comandos esenciales.</p>

                    <h3>CREATE DATABASE - Crear Base de Datos</h3>
                    <div class="code-block">
                        <code>-- Crear una base de datos
    CREATE DATABASE mi_tienda;

    -- Crear solo si no existe
    CREATE DATABASE IF NOT EXISTS mi_tienda;

    -- Crear con codificaci√≥n espec√≠fica
    CREATE DATABASE mi_tienda
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

    -- Ver bases de datos existentes
    SHOW DATABASES;

    -- Seleccionar/usar una base de datos
    USE mi_tienda;

    -- Eliminar una base de datos (¬°CUIDADO!)
    DROP DATABASE mi_tienda;</code>
                    </div>

                    <h3>Tipos de Datos en MySQL</h3>
                    <p>Es fundamental elegir el tipo de dato correcto para cada columna:</p>

                    <h4>Tipos Num√©ricos</h4>
                    <div class="code-block">
                        <code>-- Enteros
    TINYINT      -- -128 a 127 (1 byte)
    SMALLINT     -- -32,768 a 32,767 (2 bytes)
    MEDIUMINT    -- -8,388,608 a 8,388,607 (3 bytes)
    INT          -- -2,147,483,648 a 2,147,483,647 (4 bytes) - M√ÅS USADO
    BIGINT       -- N√∫meros muy grandes (8 bytes)

    -- Decimales
    DECIMAL(10,2)  -- 10 d√≠gitos totales, 2 decimales - EXACTO (para dinero)
    FLOAT          -- Decimal de precisi√≥n simple - APROXIMADO
    DOUBLE         -- Decimal de precisi√≥n doble - APROXIMADO</code>
                    </div>

                    <h4>Tipos de Texto</h4>
                    <div class="code-block">
                        <code>CHAR(n)        -- Longitud fija (rellenado con espacios)
    VARCHAR(n)     -- Longitud variable - M√ÅS USADO
    TEXT           -- Texto largo (hasta 65,535 caracteres)
    MEDIUMTEXT     -- Texto muy largo
    LONGTEXT       -- Texto gigante</code>
                    </div>

                    <h4>Tipos de Fecha/Hora</h4>
                    <div class="code-block">
                        <code>DATE           -- Fecha (YYYY-MM-DD)
    TIME           -- Hora (HH:MM:SS)
    DATETIME       -- Fecha y hora - M√ÅS USADO
    TIMESTAMP      -- Marca de tiempo (auto-actualizable)
    YEAR           -- Solo a√±o</code>
                    </div>

                    <h4>Otros Tipos</h4>
                    <div class="code-block">
                        <code>BOOLEAN / BOOL  -- True/False (internamente TINYINT(1))
    ENUM('val1', 'val2')  -- Lista de valores permitidos
    BLOB           -- Datos binarios (im√°genes, archivos)</code>
                    </div>

                    <h3>CREATE TABLE - Crear Tablas</h3>
                    <div class="code-block">
                        <code>-- Estructura b√°sica
    CREATE TABLE nombre_tabla (
        nombre_columna tipo_dato restricciones,
        ...
    );

    -- Ejemplo completo de tabla CLIENTES
    CREATE TABLE clientes (
        id_cliente INT PRIMARY KEY AUTO_INCREMENT,  -- Clave primaria auto-incremental
        nombre VARCHAR(100) NOT NULL,               -- Obligatorio
        apellidos VARCHAR(100),
        email VARCHAR(100) UNIQUE,                  -- Valor √∫nico
        telefono VARCHAR(15),
        fecha_nacimiento DATE,
        saldo DECIMAL(10,2) DEFAULT 0.00,          -- Valor por defecto
        activo BOOLEAN DEFAULT TRUE,
        fecha_registro DATETIME DEFAULT CURRENT_TIMESTAMP,  -- Fecha actual autom√°tica
        notas TEXT
    );

    -- Ejemplo tabla PRODUCTOS
    CREATE TABLE productos (
        id_producto INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(200) NOT NULL,
        descripcion TEXT,
        precio DECIMAL(10,2) NOT NULL CHECK (precio >= 0),  -- Restricci√≥n: precio >= 0
        stock INT DEFAULT 0,
        categoria ENUM('Electr√≥nica', 'Ropa', 'Alimentos', 'Hogar'),
        fecha_alta DATETIME DEFAULT CURRENT_TIMESTAMP,
        fecha_modificacion DATETIME ON UPDATE CURRENT_TIMESTAMP  -- Se actualiza autom√°ticamente
    );

    -- Tabla con CLAVE FOR√ÅNEA
    CREATE TABLE pedidos (
        id_pedido INT PRIMARY KEY AUTO_INCREMENT,
        id_cliente INT NOT NULL,
        fecha_pedido DATETIME DEFAULT CURRENT_TIMESTAMP,
        total DECIMAL(10,2),
        estado ENUM('pendiente', 'procesando', 'enviado', 'entregado') DEFAULT 'pendiente',

        FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
            ON DELETE CASCADE        -- Si eliminas cliente, eliminas sus pedidos
            ON UPDATE CASCADE        -- Si cambias id_cliente, se actualiza aqu√≠
    );

    -- Ver estructura de una tabla
    DESCRIBE clientes;
    -- o
    SHOW COLUMNS FROM clientes;</code>
                    </div>

                    <div class="warning-box">
                        <p><strong>Restricciones m√°s comunes:</strong></p>
                        <ul>
                            <li><code>PRIMARY KEY</code>: Identifica √∫nicamente cada fila</li>
                            <li><code>FOREIGN KEY</code>: Relaci√≥n con otra tabla</li>
                            <li><code>NOT NULL</code>: El campo no puede estar vac√≠o</li>
                            <li><code>UNIQUE</code>: No puede haber valores duplicados</li>
                            <li><code>DEFAULT</code>: Valor por defecto si no se especifica</li>
                            <li><code>AUTO_INCREMENT</code>: Incrementa autom√°ticamente</li>
                            <li><code>CHECK</code>: Condici√≥n que debe cumplirse</li>
                        </ul>
                    </div>

                    <h3>INSERT - Insertar Datos</h3>
                    <div class="code-block">
                        <code>-- Insertar UN registro especificando columnas
    INSERT INTO clientes (nombre, apellidos, email, telefono)
    VALUES ('Ana', 'Garc√≠a L√≥pez', 'ana@email.com', '600123456');

    -- Insertar especificando TODAS las columnas (en orden)
    INSERT INTO productos
    VALUES (NULL, 'Laptop HP 15', 'Port√°til 15.6 pulgadas', 599.99, 10, 'Electr√≥nica', NOW(), NULL);

    -- Insertar M√öLTIPLES registros a la vez (m√°s eficiente)
    INSERT INTO productos (nombre, precio, stock, categoria)
    VALUES
        ('Mouse Logitech', 25.50, 50, 'Electr√≥nica'),
        ('Teclado Mec√°nico', 89.99, 30, 'Electr√≥nica'),
        ('Silla Oficina', 149.99, 15, 'Hogar'),
        ('Camiseta Algod√≥n', 19.99, 100, 'Ropa');

    -- Insertar desde otra tabla (SELECT)
    INSERT INTO clientes_vip (id_cliente, nombre, email)
    SELECT id_cliente, nombre, email
    FROM clientes
    WHERE saldo > 1000;

    -- Ver el ID del √∫ltimo registro insertado
    SELECT LAST_INSERT_ID();</code>
                    </div>

                    <h3>SELECT - Consultar Datos</h3>
                    <p>SELECT es el comando M√ÅS USADO en SQL. Permite recuperar datos de las tablas.</p>

                    <h4>SELECT B√°sico</h4>
                    <div class="code-block">
                        <code>-- Seleccionar TODAS las columnas
    SELECT * FROM clientes;

    -- Seleccionar columnas espec√≠ficas
    SELECT nombre, email FROM clientes;

    -- Seleccionar con alias (AS)
    SELECT
        nombre AS cliente,
        email AS correo,
        saldo AS balance
    FROM clientes;

    -- Combinar columnas (CONCAT)
    SELECT
        CONCAT(nombre, ' ', apellidos) AS nombre_completo,
        email
    FROM clientes;

    -- C√°lculos en SELECT
    SELECT
        nombre,
        precio,
        precio * 0.21 AS iva,
        precio * 1.21 AS precio_final
    FROM productos;</code>
                    </div>

                    <h4>WHERE - Filtrar Resultados</h4>
                    <div class="code-block">
                        <code>-- Condici√≥n simple
    SELECT * FROM productos WHERE precio > 50;

    -- M√∫ltiples condiciones con AND
    SELECT * FROM productos
    WHERE precio > 50 AND stock > 0;

    -- Condiciones con OR
    SELECT * FROM productos
    WHERE categoria = 'Electr√≥nica' OR categoria = 'Hogar';

    -- BETWEEN (rango de valores)
    SELECT * FROM productos
    WHERE precio BETWEEN 20 AND 100;

    -- IN (lista de valores)
    SELECT * FROM productos
    WHERE categoria IN ('Electr√≥nica', 'Hogar', 'Ropa');

    -- NOT IN
    SELECT * FROM clientes
    WHERE id_cliente NOT IN (1, 2, 3);

    -- IS NULL / IS NOT NULL
    SELECT * FROM clientes WHERE telefono IS NULL;
    SELECT * FROM clientes WHERE email IS NOT NULL;

    -- LIKE (b√∫squeda de patrones)
    SELECT * FROM clientes WHERE nombre LIKE 'Ana%';     -- Empieza con "Ana"
    SELECT * FROM clientes WHERE email LIKE '%@gmail.com';  -- Termina con "@gmail.com"
    SELECT * FROM productos WHERE nombre LIKE '%laptop%';   -- Contiene "laptop"
    SELECT * FROM clientes WHERE nombre LIKE '_a%';      -- Segunda letra es 'a'

    -- COMPARACIONES
    SELECT * FROM productos WHERE precio = 25.50;
    SELECT * FROM productos WHERE precio != 25.50;   -- o <>
    SELECT * FROM productos WHERE stock >= 10;
    SELECT * FROM productos WHERE fecha_alta < '2024-01-01';</code>
                    </div>

                    <h4>ORDER BY - Ordenar Resultados</h4>
                    <div class="code-block">
                        <code>-- Ordenar ascendente (por defecto)
    SELECT * FROM productos ORDER BY precio;
    SELECT * FROM productos ORDER BY precio ASC;  -- Expl√≠cito

    -- Ordenar descendente
    SELECT * FROM productos ORDER BY precio DESC;

    -- Ordenar por m√∫ltiples columnas
    SELECT * FROM productos
    ORDER BY categoria ASC, precio DESC;

    -- Ordenar con c√°lculos
    SELECT nombre, precio, precio * 1.21 AS precio_final
    FROM productos
    ORDER BY precio_final DESC;

    -- Orden alfab√©tico
    SELECT * FROM clientes ORDER BY apellidos, nombre;</code>
                    </div>

                    <h4>LIMIT - Limitar Resultados</h4>
                    <div class="code-block">
                        <code>-- Primeros 10 registros
    SELECT * FROM productos LIMIT 10;

    -- Paginaci√≥n: LIMIT offset, cantidad
    SELECT * FROM productos LIMIT 0, 10;   -- P√°gina 1 (registros 1-10)
    SELECT * FROM productos LIMIT 10, 10;  -- P√°gina 2 (registros 11-20)
    SELECT * FROM productos LIMIT 20, 10;  -- P√°gina 3 (registros 21-30)

    -- Top 5 productos m√°s caros
    SELECT nombre, precio
    FROM productos
    ORDER BY precio DESC
    LIMIT 5;

    -- Productos m√°s baratos (excepto el m√°s barato)
    SELECT * FROM productos
    ORDER BY precio
    LIMIT 1, 10;  -- Omite el primero, muestra los siguientes 10</code>
                    </div>

                    <h4>DISTINCT - Valores √önicos</h4>
                    <div class="code-block">
                        <code>-- Sin duplicados
    SELECT DISTINCT categoria FROM productos;

    -- Contar valores √∫nicos
    SELECT COUNT(DISTINCT categoria) AS categorias_diferentes
    FROM productos;

    -- Combinaci√≥n de columnas √∫nicas
    SELECT DISTINCT categoria, stock
    FROM productos;</code>
                    </div>

                    <h3>UPDATE - Actualizar Datos</h3>
                    <div class="code-block">
                        <code>-- Actualizar UN campo
    UPDATE productos
    SET precio = 549.99
    WHERE id_producto = 1;

    -- Actualizar M√öLTIPLES campos
    UPDATE productos
    SET
        precio = 89.99,
        stock = 25,
        fecha_modificacion = NOW()
    WHERE id_producto = 2;

    -- Actualizar con condiciones
    UPDATE productos
    SET precio = precio * 1.10  -- Incrementar 10%
    WHERE categoria = 'Electr√≥nica';

    -- Actualizar basado en otra tabla (subconsulta)
    UPDATE clientes
    SET saldo = saldo + 100
    WHERE id_cliente IN (
        SELECT id_cliente FROM pedidos
        WHERE fecha_pedido >= '2024-01-01'
    );

    -- Actualizar TODOS los registros (¬°CUIDADO!)
    UPDATE productos SET stock = 0;  -- Pone stock a 0 en TODOS</code>
                    </div>

                    <div class="warning-box">
                        <p><strong>¬°MUY IMPORTANTE!</strong> Siempre usa WHERE en UPDATE para evitar actualizar TODOS los registros por error. Antes de ejecutar, prueba con SELECT para verificar qu√© registros afectar√°s:</p>
                        <code>-- PRIMERO: Ver qu√© se actualizar√°
    SELECT * FROM productos WHERE categoria = 'Electr√≥nica';

    -- LUEGO: Actualizar
    UPDATE productos SET precio = precio * 1.10 WHERE categoria = 'Electr√≥nica';</code>
                    </div>

                    <h3>DELETE - Eliminar Datos</h3>
                    <div class="code-block">
                        <code>-- Eliminar registro espec√≠fico
    DELETE FROM productos WHERE id_producto = 10;

    -- Eliminar con condici√≥n
    DELETE FROM clientes WHERE activo = FALSE;

    -- Eliminar m√∫ltiples registros
    DELETE FROM pedidos
    WHERE fecha_pedido < '2023-01-01';

    -- Eliminar productos sin stock
    DELETE FROM productos WHERE stock = 0;

    -- Eliminar con subconsulta
    DELETE FROM productos
    WHERE id_categoria IN (
        SELECT id_categoria FROM categorias WHERE activa = FALSE
    );

    -- Eliminar TODOS los registros (¬°CUIDADO!)
    DELETE FROM productos;  -- Elimina TODO pero mantiene estructura

    -- TRUNCATE: Vaciar tabla completamente (m√°s r√°pido, resetea AUTO_INCREMENT)
    TRUNCATE TABLE productos;</code>
                    </div>

                    <div class="warning-box">
                        <p><strong>Errores Comunes - SQL B√°sico:</strong></p>
                        <ul>
                            <li><strong>UPDATE/DELETE sin WHERE:</strong> Modifica/elimina TODOS los registros</li>
                            <li><strong>Olvidar punto y coma (;):</strong> En algunos clientes SQL es obligatorio</li>
                            <li><strong>Nombres con espacios sin comillas:</strong> Usa `nombre con espacios` con backticks</li>
                            <li><strong>Comparar NULL con =:</strong> Usa IS NULL, no = NULL</li>
                            <li><strong>LIKE sin %:</strong> LIKE 'Ana' solo encuentra exactamente "Ana", usa 'Ana%' para "empieza con"</li>
                        </ul>
                    </div>

                    <div class="note-box">
                        <p><strong>Trucos Pro - SQL B√°sico:</strong></p>
                        <ul>
                            <li>Usa <code>SELECT COUNT(*) FROM tabla</code> para contar registros</li>
                            <li>Comenta c√≥digo SQL: <code>-- comentario de l√≠nea</code> o <code>/* multi-l√≠nea */</code></li>
                            <li>Formatea queries: una cl√°usula por l√≠nea para mejor legibilidad</li>
                            <li>Usa <code>EXPLAIN SELECT ...</code> para ver c√≥mo MySQL ejecuta la query</li>
                            <li>Activa el modo seguro (safe mode) en Workbench para prevenir DELETE/UPDATE sin WHERE</li>
                        </ul>
                    </div>
                </section>

                <!-- SQL INTERMEDIO -->
                <section id="sql-intermedio" class="content-section">
                    <h2 class="section-title">SQL Intermedio</h2>

                    <!-- JOINs -->
                    <article class="topic">
                        <h3 class="topic-title">JOINs - Unir Tablas</h3>
                        <p class="topic-description">
                            Los <strong>JOINs</strong> permiten combinar filas de dos o m√°s tablas bas√°ndose en columnas relacionadas.
                            Son fundamentales en bases de datos relacionales para obtener informaci√≥n de m√∫ltiples tablas.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Tipos de JOIN - Diagramas Conceptuales</span>
                            </div>
                            <pre><code class="language-sql">-- INNER JOIN (Intersecci√≥n)
    --     Tabla A          Tabla B
    --   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    --   ‚îÇ    A    ‚îÇ      ‚îÇ    B    ‚îÇ
    --   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ      ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
    --   ‚îÇ  ‚îÇ A‚à©B ‚îÇ  ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  ‚îÇ A‚à©B ‚îÇ  ‚îÇ  INNER JOIN: Solo registros que coinciden en AMBAS tablas
    --   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ      ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
    --   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    --
    -- LEFT JOIN (Todos de A + coincidencias de B)
    --     Tabla A          Tabla B
    --   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    --   ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ      ‚îÇ    B    ‚îÇ
    --   ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ  ‚Üê‚îÄ‚îÄ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  LEFT JOIN: TODOS los registros de tabla izquierda
    --   ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ      ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ           + coincidencias de tabla derecha
    --   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    --
    -- RIGHT JOIN (Coincidencias de A + todos de B)
    --     Tabla A          Tabla B
    --   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    --   ‚îÇ    A    ‚îÇ      ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
    --   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ   ‚îÄ‚îÄ‚îÄ‚Üí ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ  RIGHT JOIN: Coincidencias de tabla izquierda
    --   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ      ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ            + TODOS los registros de tabla derecha
    --   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 1: INNER JOIN - Clientes con Pedidos</span>
                            </div>
                            <pre><code class="language-sql">-- Preparaci√≥n: Crear tablas para ejemplos de JOINs
    CREATE TABLE clientes (
        id_cliente INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100) NOT NULL,
        email VARCHAR(100),
        ciudad VARCHAR(50)
    );

    CREATE TABLE pedidos (
        id_pedido INT PRIMARY KEY AUTO_INCREMENT,
        id_cliente INT,                      -- FK hacia clientes
        fecha_pedido DATE,
        total DECIMAL(10,2),
        FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
    );

    -- Insertar datos de prueba
    INSERT INTO clientes (nombre, email, ciudad) VALUES
        ('Ana Garc√≠a', 'ana@email.com', 'Madrid'),
        ('Carlos L√≥pez', 'carlos@email.com', 'Barcelona'),
        ('Mar√≠a S√°nchez', 'maria@email.com', 'Valencia'),
        ('Juan P√©rez', 'juan@email.com', 'Sevilla');     -- Juan NO tiene pedidos

    INSERT INTO pedidos (id_cliente, fecha_pedido, total) VALUES
        (1, '2024-01-15', 150.00),    -- Pedido de Ana
        (1, '2024-02-20', 89.99),     -- Otro pedido de Ana
        (2, '2024-01-18', 299.50),    -- Pedido de Carlos
        (3, '2024-03-10', 45.00);     -- Pedido de Mar√≠a

    -- INNER JOIN: Solo clientes QUE TIENEN pedidos
    SELECT
        c.nombre,                    -- c = alias para clientes
        c.ciudad,
        p.id_pedido,                 -- p = alias para pedidos
        p.fecha_pedido,
        p.total
    FROM clientes c
    INNER JOIN pedidos p ON c.id_cliente = p.id_cliente;  -- Condici√≥n de uni√≥n

    -- Resultado: 4 filas (Ana aparece 2 veces porque tiene 2 pedidos)
    -- Juan NO aparece porque no tiene pedidos (INNER JOIN solo muestra coincidencias)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 2: LEFT JOIN - Todos los Clientes</span>
                            </div>
                            <pre><code class="language-sql">-- LEFT JOIN: TODOS los clientes, tengan o no pedidos
    SELECT
        c.nombre,
        c.ciudad,
        p.id_pedido,
        p.fecha_pedido,
        p.total
    FROM clientes c
    LEFT JOIN pedidos p ON c.id_cliente = p.id_cliente;

    -- Resultado: 4 filas + Juan P√©rez aparece con valores NULL en columnas de pedidos
    -- Ana Garc√≠a    | Madrid    | 1 | 2024-01-15 | 150.00
    -- Ana Garc√≠a    | Madrid    | 2 | 2024-02-20 | 89.99
    -- Carlos L√≥pez  | Barcelona | 3 | 2024-01-18 | 299.50
    -- Mar√≠a S√°nchez | Valencia  | 4 | 2024-03-10 | 45.00
    -- Juan P√©rez    | Sevilla   | NULL | NULL    | NULL   ‚Üê Aparece con LEFT JOIN

    -- Uso pr√°ctico: Encontrar clientes SIN pedidos
    SELECT
        c.nombre,
        c.email
    FROM clientes c
    LEFT JOIN pedidos p ON c.id_cliente = p.id_cliente
    WHERE p.id_pedido IS NULL;  -- Filtra donde NO hay coincidencia

    -- Resultado: Juan P√©rez (clientes sin pedidos)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 3: RIGHT JOIN</span>
                            </div>
                            <pre><code class="language-sql">-- RIGHT JOIN: Todos los pedidos + datos de cliente si existen
    -- (En la pr√°ctica, RIGHT JOIN es menos usado, se prefiere LEFT JOIN invirtiendo el orden)

    SELECT
        p.id_pedido,
        p.fecha_pedido,
        p.total,
        c.nombre,
        c.ciudad
    FROM clientes c
    RIGHT JOIN pedidos p ON c.id_cliente = p.id_cliente;

    -- Equivalente con LEFT JOIN (PREFERIDO):
    SELECT
        p.id_pedido,
        p.fecha_pedido,
        p.total,
        c.nombre,
        c.ciudad
    FROM pedidos p
    LEFT JOIN clientes c ON p.id_cliente = c.id_cliente;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 4: JOIN con 3 Tablas</span>
                            </div>
                            <pre><code class="language-sql">-- Crear tabla de productos
    CREATE TABLE productos (
        id_producto INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100),
        precio DECIMAL(10,2),
        stock INT
    );

    -- Crear tabla intermedia: detalle de pedidos (N:M entre pedidos y productos)
    CREATE TABLE detalle_pedidos (
        id_detalle INT PRIMARY KEY AUTO_INCREMENT,
        id_pedido INT,
        id_producto INT,
        cantidad INT,
        precio_unitario DECIMAL(10,2),  -- Precio en el momento de la compra
        FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido),
        FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
    );

    INSERT INTO productos (nombre, precio, stock) VALUES
        ('Laptop HP', 699.00, 15),
        ('Mouse Logitech', 25.50, 100),
        ('Teclado Mec√°nico', 89.99, 45);

    INSERT INTO detalle_pedidos (id_pedido, id_producto, cantidad, precio_unitario) VALUES
        (1, 2, 2, 25.50),   -- Pedido 1 (Ana): 2 ratones
        (1, 3, 1, 89.99),   -- Pedido 1 (Ana): 1 teclado
        (3, 1, 1, 699.00);  -- Pedido 3 (Carlos): 1 laptop

    -- JOIN de 4 tablas: Ver qu√© productos compr√≥ cada cliente
    SELECT
        c.nombre AS cliente,
        p.id_pedido,
        p.fecha_pedido,
        prod.nombre AS producto,
        dp.cantidad,
        dp.precio_unitario,
        (dp.cantidad * dp.precio_unitario) AS subtotal  -- C√°lculo en SELECT
    FROM clientes c
    INNER JOIN pedidos p ON c.id_cliente = p.id_cliente
    INNER JOIN detalle_pedidos dp ON p.id_pedido = dp.id_pedido
    INNER JOIN productos prod ON dp.id_producto = prod.id_producto
    ORDER BY c.nombre, p.fecha_pedido;

    -- Resultado:
    -- Ana Garc√≠a   | 1 | 2024-01-15 | Mouse Logitech    | 2 | 25.50 | 51.00
    -- Ana Garc√≠a   | 1 | 2024-01-15 | Teclado Mec√°nico  | 1 | 89.99 | 89.99
    -- Carlos L√≥pez | 3 | 2024-01-18 | Laptop HP         | 1 | 699.00 | 699.00</code></pre>
                        </div>
                    </article>

                    <!-- GROUP BY y Funciones Agregadas -->
                    <article class="topic">
                        <h3 class="topic-title">GROUP BY y Funciones Agregadas</h3>
                        <p class="topic-description">
                            <strong>GROUP BY</strong> agrupa filas con valores iguales en columnas especificadas.
                            Se usa con <strong>funciones agregadas</strong> para calcular valores sobre grupos de datos.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Funciones Agregadas Principales</span>
                            </div>
                            <pre><code class="language-sql">-- COUNT(): Cuenta registros
    SELECT COUNT(*) AS total_productos FROM productos;
    SELECT COUNT(DISTINCT ciudad) AS ciudades_unicas FROM clientes;

    -- SUM(): Suma valores num√©ricos
    SELECT SUM(total) AS ventas_totales FROM pedidos;

    -- AVG(): Promedio
    SELECT AVG(precio) AS precio_promedio FROM productos;

    -- MAX() y MIN(): Valores m√°ximo y m√≠nimo
    SELECT
        MAX(precio) AS producto_mas_caro,
        MIN(precio) AS producto_mas_barato
    FROM productos;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 5: GROUP BY B√°sico</span>
                            </div>
                            <pre><code class="language-sql">-- Contar cu√°ntos clientes hay por ciudad
    SELECT
        ciudad,
        COUNT(*) AS num_clientes
    FROM clientes
    GROUP BY ciudad;  -- Agrupa por ciudad

    -- Resultado:
    -- Madrid    | 1
    -- Barcelona | 1
    -- Valencia  | 1
    -- Sevilla   | 1

    -- Total gastado por cada cliente
    SELECT
        c.nombre,
        COUNT(p.id_pedido) AS num_pedidos,
        SUM(p.total) AS total_gastado,
        AVG(p.total) AS promedio_por_pedido
    FROM clientes c
    LEFT JOIN pedidos p ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre  -- Agrupar por cliente
    ORDER BY total_gastado DESC;

    -- Resultado:
    -- Ana Garc√≠a    | 2 | 239.99 | 119.995
    -- Carlos L√≥pez  | 1 | 299.50 | 299.50
    -- Mar√≠a S√°nchez | 1 | 45.00  | 45.00
    -- Juan P√©rez    | 0 | NULL   | NULL</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 6: HAVING - Filtrar Grupos</span>
                            </div>
                            <pre><code class="language-sql">-- HAVING filtra DESPU√âS de agrupar (WHERE filtra ANTES de agrupar)

    -- Clientes que han hecho M√ÅS DE 1 pedido
    SELECT
        c.nombre,
        COUNT(p.id_pedido) AS num_pedidos
    FROM clientes c
    INNER JOIN pedidos p ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
    HAVING COUNT(p.id_pedido) > 1;  -- Filtra grupos donde count > 1

    -- Resultado: Ana Garc√≠a | 2

    -- Ciudades con m√°s de 1 cliente
    SELECT
        ciudad,
        COUNT(*) AS num_clientes
    FROM clientes
    GROUP BY ciudad
    HAVING COUNT(*) > 1;

    -- Productos que se vendieron m√°s de 1 vez (en total)
    SELECT
        prod.nombre,
        SUM(dp.cantidad) AS total_vendido,
        COUNT(dp.id_detalle) AS num_ventas
    FROM productos prod
    INNER JOIN detalle_pedidos dp ON prod.id_producto = dp.id_producto
    GROUP BY prod.id_producto, prod.nombre
    HAVING SUM(dp.cantidad) > 1
    ORDER BY total_vendido DESC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 7: GROUP BY con Fechas</span>
                            </div>
                            <pre><code class="language-sql">-- Ventas por mes (agrupar por a√±o y mes)
    SELECT
        YEAR(fecha_pedido) AS a√±o,
        MONTH(fecha_pedido) AS mes,
        COUNT(*) AS num_pedidos,
        SUM(total) AS ventas_totales,
        AVG(total) AS ticket_promedio
    FROM pedidos
    GROUP BY YEAR(fecha_pedido), MONTH(fecha_pedido)
    ORDER BY a√±o, mes;

    -- Resultado:
    -- 2024 | 1 | 2 | 449.50 | 224.75  (Enero 2024)
    -- 2024 | 2 | 1 | 89.99  | 89.99   (Febrero 2024)
    -- 2024 | 3 | 1 | 45.00  | 45.00   (Marzo 2024)

    -- Pedidos por d√≠a de la semana
    SELECT
        DAYNAME(fecha_pedido) AS dia_semana,
        COUNT(*) AS num_pedidos
    FROM pedidos
    GROUP BY DAYNAME(fecha_pedido), DAYOFWEEK(fecha_pedido)
    ORDER BY DAYOFWEEK(fecha_pedado);</code></pre>
                        </div>
                    </article>

                    <!-- Subconsultas -->
                    <article class="topic">
                        <h3 class="topic-title">Subconsultas (Subqueries)</h3>
                        <p class="topic-description">
                            Una <strong>subconsulta</strong> es una query SELECT dentro de otra query.
                            Puede aparecer en cl√°usulas SELECT, WHERE, FROM, HAVING.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 8: Subconsulta en WHERE</span>
                            </div>
                            <pre><code class="language-sql">-- Productos con precio MAYOR al precio promedio
    SELECT
        nombre,
        precio
    FROM productos
    WHERE precio > (SELECT AVG(precio) FROM productos);  -- Subconsulta devuelve un valor

    -- Desglose:
    -- 1. Subconsulta calcula: AVG(precio) = 271.50
    -- 2. Query externa busca productos con precio > 271.50

    -- Clientes que han gastado M√ÅS que el promedio
    SELECT
        c.nombre,
        SUM(p.total) AS total_gastado
    FROM clientes c
    INNER JOIN pedidos p ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
    HAVING SUM(p.total) > (
        SELECT AVG(total_por_cliente)
        FROM (
            SELECT SUM(total) AS total_por_cliente
            FROM pedidos
            GROUP BY id_cliente
        ) AS subquery
    );</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 9: Subconsulta con IN</span>
                            </div>
                            <pre><code class="language-sql">-- Clientes que han comprado laptops
    SELECT
        nombre,
        email
    FROM clientes
    WHERE id_cliente IN (
        -- Subconsulta: IDs de clientes que compraron producto 1 (Laptop)
        SELECT DISTINCT p.id_cliente
        FROM pedidos p
        INNER JOIN detalle_pedidos dp ON p.id_pedido = dp.id_pedido
        WHERE dp.id_producto = 1
    );

    -- Productos que NUNCA se han vendido
    SELECT
        nombre,
        precio,
        stock
    FROM productos
    WHERE id_producto NOT IN (
        SELECT DISTINCT id_producto
        FROM detalle_pedidos
    );

    -- Alternativa con LEFT JOIN (suele ser m√°s eficiente):
    SELECT
        prod.nombre,
        prod.precio,
        prod.stock
    FROM productos prod
    LEFT JOIN detalle_pedidos dp ON prod.id_producto = dp.id_producto
    WHERE dp.id_producto IS NULL;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 10: Subconsulta en SELECT</span>
                            </div>
                            <pre><code class="language-sql">-- Mostrar cada cliente con su total gastado (subconsulta correlacionada)
    SELECT
        c.nombre,
        c.ciudad,
        (
            SELECT COUNT(*)
            FROM pedidos p
            WHERE p.id_cliente = c.id_cliente  -- Correlacionada: usa c de query externa
        ) AS num_pedidos,
        (
            SELECT IFNULL(SUM(total), 0)
            FROM pedidos p
            WHERE p.id_cliente = c.id_cliente
        ) AS total_gastado
    FROM clientes c
    ORDER BY total_gastado DESC;

    -- Nota: Esta query se ejecuta as√≠:
    -- 1. Por cada fila de clientes (c)
    -- 2. Ejecuta las 2 subconsultas para ese cliente espec√≠fico
    -- 3. Puede ser lento con muchos registros (mejor usar JOIN + GROUP BY)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 11: Subconsulta en FROM (Tabla Derivada)</span>
                            </div>
                            <pre><code class="language-sql">-- Ranking de productos m√°s vendidos
    SELECT
        producto,
        total_vendido,
        num_ventas
    FROM (
        -- Subconsulta crea tabla temporal con totales por producto
        SELECT
            prod.nombre AS producto,
            SUM(dp.cantidad) AS total_vendido,
            COUNT(dp.id_detalle) AS num_ventas
        FROM productos prod
        INNER JOIN detalle_pedidos dp ON prod.id_producto = dp.id_producto
        GROUP BY prod.id_producto, prod.nombre
    ) AS ranking  -- OBLIGATORIO: dar alias a tabla derivada
    WHERE total_vendido > 1
    ORDER BY total_vendido DESC;

    -- Promedio de ventas mensuales
    SELECT
        AVG(ventas_mes) AS promedio_mensual,
        MAX(ventas_mes) AS mejor_mes,
        MIN(ventas_mes) AS peor_mes
    FROM (
        SELECT
            YEAR(fecha_pedido) AS a√±o,
            MONTH(fecha_pedido) AS mes,
            SUM(total) AS ventas_mes
        FROM pedidos
        GROUP BY YEAR(fecha_pedido), MONTH(fecha_pedido)
    ) AS ventas_por_mes;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 12: EXISTS - Comprobar Existencia</span>
                            </div>
                            <pre><code class="language-sql">-- Clientes que S√ç tienen pedidos (con EXISTS)
    SELECT
        c.nombre,
        c.email
    FROM clientes c
    WHERE EXISTS (
        SELECT 1  -- No importa qu√© seleccionas, solo si existe
        FROM pedidos p
        WHERE p.id_cliente = c.id_cliente
    );

    -- Clientes que NO tienen pedidos (con NOT EXISTS)
    SELECT
        c.nombre,
        c.email
    FROM clientes c
    WHERE NOT EXISTS (
        SELECT 1
        FROM pedidos p
        WHERE p.id_cliente = c.id_cliente
    );

    -- EXISTS vs IN:
    -- EXISTS: M√°s eficiente cuando hay muchos registros (se detiene al encontrar el primero)
    -- IN: Mejor para listas peque√±as de valores</code></pre>
                        </div>
                    </article>

                    <!-- Queries Complejas Adicionales -->
                    <article class="topic">
                        <h3 class="topic-title">Queries Complejas - Casos Pr√°cticos</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 13: Top 5 Productos M√°s Vendidos con Ingresos</span>
                            </div>
                            <pre><code class="language-sql">-- Top 5 productos m√°s vendidos con sus ingresos totales
    SELECT
        prod.nombre,
        SUM(dp.cantidad) AS unidades_vendidas,
        SUM(dp.cantidad * dp.precio_unitario) AS ingresos_totales,
        COUNT(DISTINCT dp.id_pedido) AS num_pedidos_distintos,
        AVG(dp.precio_unitario) AS precio_promedio_venta
    FROM productos prod
    INNER JOIN detalle_pedidos dp ON prod.id_producto = dp.id_producto
    GROUP BY prod.id_producto, prod.nombre
    ORDER BY unidades_vendidas DESC
    LIMIT 5;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 14: Clientes VIP (m√°s de 200‚Ç¨ gastados)</span>
                            </div>
                            <pre><code class="language-sql">-- Identificar clientes VIP y su comportamiento de compra
    SELECT
        c.nombre,
        c.ciudad,
        COUNT(p.id_pedido) AS num_pedidos,
        SUM(p.total) AS total_gastado,
        AVG(p.total) AS ticket_promedio,
        MAX(p.fecha_pedido) AS ultima_compra,
        DATEDIFF(CURDATE(), MAX(p.fecha_pedido)) AS dias_sin_comprar
    FROM clientes c
    INNER JOIN pedidos p ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre, c.ciudad
    HAVING SUM(p.total) > 200  -- Solo clientes VIP
    ORDER BY total_gastado DESC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 15: Productos con Stock Bajo y Sus Ventas</span>
                            </div>
                            <pre><code class="language-sql">-- Productos con stock < 50 y sus estad√≠sticas de venta
    SELECT
        prod.nombre,
        prod.stock AS stock_actual,
        prod.precio AS precio_actual,
        IFNULL(SUM(dp.cantidad), 0) AS total_vendido,
        IFNULL(COUNT(dp.id_detalle), 0) AS num_ventas,
        CASE
            WHEN prod.stock < 10 THEN 'CR√çTICO'
            WHEN prod.stock < 30 THEN 'BAJO'
            ELSE 'NORMAL'
        END AS nivel_stock
    FROM productos prod
    LEFT JOIN detalle_pedidos dp ON prod.id_producto = dp.id_producto
    WHERE prod.stock < 50
    GROUP BY prod.id_producto, prod.nombre, prod.stock, prod.precio
    ORDER BY prod.stock ASC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 16: An√°lisis de Ventas por Ciudad</span>
                            </div>
                            <pre><code class="language-sql">-- Ventas totales por ciudad de los clientes
    SELECT
        c.ciudad,
        COUNT(DISTINCT c.id_cliente) AS num_clientes,
        COUNT(p.id_pedido) AS num_pedidos,
        SUM(p.total) AS ventas_totales,
        AVG(p.total) AS ticket_promedio,
        SUM(p.total) / COUNT(DISTINCT c.id_cliente) AS gasto_promedio_cliente
    FROM clientes c
    LEFT JOIN pedidos p ON c.id_cliente = p.id_cliente
    GROUP BY c.ciudad
    HAVING ventas_totales IS NOT NULL  -- Solo ciudades con ventas
    ORDER BY ventas_totales DESC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 17: Productos Complementarios (Comprados Juntos)</span>
                            </div>
                            <pre><code class="language-sql">-- Encuentra pares de productos que se compraron en el mismo pedido
    SELECT
        p1.nombre AS producto_1,
        p2.nombre AS producto_2,
        COUNT(*) AS veces_juntos
    FROM detalle_pedidos dp1
    INNER JOIN detalle_pedidos dp2 ON dp1.id_pedido = dp2.id_pedido
    INNER JOIN productos p1 ON dp1.id_producto = p1.id_producto
    INNER JOIN productos p2 ON dp2.id_producto = p2.id_producto
    WHERE dp1.id_producto < dp2.id_producto  -- Evita duplicados (A,B) y (B,A)
    GROUP BY p1.id_producto, p1.nombre, p2.id_producto, p2.nombre
    HAVING COUNT(*) >= 1  -- M√≠nimo comprados juntos 1 vez
    ORDER BY veces_juntos DESC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 18: Comparaci√≥n con Per√≠odo Anterior</span>
                            </div>
                            <pre><code class="language-sql">-- Comparar ventas del mes actual vs mes anterior
    SELECT
        'Mes Actual' AS periodo,
        COUNT(*) AS num_pedidos,
        SUM(total) AS ventas
    FROM pedidos
    WHERE YEAR(fecha_pedido) = YEAR(CURDATE())
    AND MONTH(fecha_pedido) = MONTH(CURDATE())

    UNION ALL

    SELECT
        'Mes Anterior' AS periodo,
        COUNT(*) AS num_pedidos,
        SUM(total) AS ventas
    FROM pedidos
    WHERE fecha_pedido >= DATE_SUB(DATE_FORMAT(CURDATE(), '%Y-%m-01'), INTERVAL 1 MONTH)
    AND fecha_pedido < DATE_FORMAT(CURDATE(), '%Y-%m-01');</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 19: Clientes Nuevos vs Recurrentes</span>
                            </div>
                            <pre><code class="language-sql">-- Clasificar clientes seg√∫n n√∫mero de compras
    SELECT
        CASE
            WHEN num_pedidos = 1 THEN 'Cliente Nuevo'
            WHEN num_pedidos BETWEEN 2 AND 3 THEN 'Cliente Ocasional'
            ELSE 'Cliente Recurrente'
        END AS tipo_cliente,
        COUNT(*) AS cantidad,
        SUM(total_gastado) AS ventas_totales,
        AVG(total_gastado) AS promedio_gasto
    FROM (
        SELECT
            c.id_cliente,
            COUNT(p.id_pedido) AS num_pedidos,
            SUM(p.total) AS total_gastado
        FROM clientes c
        LEFT JOIN pedidos p ON c.id_cliente = p.id_cliente
        GROUP BY c.id_cliente
    ) AS clasificacion
    GROUP BY tipo_cliente
    ORDER BY promedio_gasto DESC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 20: Productos Sin Ventas en 30 D√≠as</span>
                            </div>
                            <pre><code class="language-sql">-- Productos que no se vendieron en los √∫ltimos 30 d√≠as
    SELECT
        prod.nombre,
        prod.stock,
        prod.precio,
        MAX(p.fecha_pedido) AS ultima_venta,
        DATEDIFF(CURDATE(), MAX(p.fecha_pedido)) AS dias_sin_venta
    FROM productos prod
    LEFT JOIN detalle_pedidos dp ON prod.id_producto = dp.id_producto
    LEFT JOIN pedidos p ON dp.id_pedido = p.id_pedido
    GROUP BY prod.id_producto, prod.nombre, prod.stock, prod.precio
    HAVING ultima_venta IS NULL
        OR DATEDIFF(CURDATE(), MAX(p.fecha_pedido)) > 30
    ORDER BY dias_sin_venta DESC;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 21: Reporte Completo de Ventas (Query Maestra)</span>
                            </div>
                            <pre><code class="language-sql">-- Reporte completo: Cliente, Pedido, Productos, Totales
    SELECT
        -- Informaci√≥n del cliente
        c.nombre AS cliente,
        c.email,
        c.ciudad,

        -- Informaci√≥n del pedido
        p.id_pedido,
        p.fecha_pedido,
        DATE_FORMAT(p.fecha_pedido, '%d/%m/%Y') AS fecha_formateada,

        -- Detalles de productos
        GROUP_CONCAT(
            CONCAT(prod.nombre, ' (x', dp.cantidad, ')')
            SEPARATOR ', '
        ) AS productos_comprados,

        -- M√©tricas financieras
        SUM(dp.cantidad) AS total_items,
        SUM(dp.cantidad * dp.precio_unitario) AS subtotal_productos,
        p.total AS total_pedido,

        -- An√°lisis
        CASE
            WHEN p.total > 500 THEN 'Pedido Grande'
            WHEN p.total > 100 THEN 'Pedido Mediano'
            ELSE 'Pedido Peque√±o'
        END AS categoria_pedido

    FROM clientes c
    INNER JOIN pedidos p ON c.id_cliente = p.id_cliente
    INNER JOIN detalle_pedidos dp ON p.id_pedido = dp.id_pedido
    INNER JOIN productos prod ON dp.id_producto = prod.id_producto

    GROUP BY
        c.id_cliente, c.nombre, c.email, c.ciudad,
        p.id_pedido, p.fecha_pedido, p.total

    ORDER BY p.fecha_pedido DESC, c.nombre;</code></pre>
                        </div>
                    </article>

                    <!-- Errores Comunes -->
                    <div class="error-box">
                        <div class="error-title">‚ö†Ô∏è Errores Comunes en SQL Intermedio</div>
                        <ul class="error-list">
                            <li><strong>Olvidar la condici√≥n ON en JOIN:</strong> Sin <code>ON</code> obtienes un producto cartesiano (todas las combinaciones)</li>
                            <li><strong>Usar WHERE en vez de HAVING:</strong> <code>WHERE</code> filtra filas individuales, <code>HAVING</code> filtra grupos</li>
                            <li><strong>No incluir columnas en GROUP BY:</strong> Todas las columnas no agregadas deben estar en <code>GROUP BY</code></li>
                            <li><strong>Subconsultas sin alias:</strong> Tablas derivadas en FROM DEBEN tener alias</li>
                            <li><strong>Comparar con NULL usando =:</strong> Usa <code>IS NULL</code> o <code>IS NOT NULL</code>, nunca <code>= NULL</code></li>
                            <li><strong>LEFT JOIN con WHERE que elimina NULLs:</strong> <code>WHERE tabla_derecha.columna = valor</code> convierte LEFT JOIN en INNER JOIN</li>
                            <li><strong>Subconsultas que devuelven m√∫ltiples filas con =:</strong> Usa <code>IN</code> en vez de <code>=</code> si subconsulta puede devolver varios valores</li>
                        </ul>
                    </div>

                    <!-- Pro Tips -->
                    <div class="tip-box">
                        <div class="tip-title">üí° Pro Tips - SQL Intermedio</div>
                        <ul class="tip-list">
                            <li>Usa <strong>EXPLAIN</strong> antes de queries complejas para ver el plan de ejecuci√≥n</li>
                            <li>Prefiere <strong>JOIN</strong> sobre subconsultas cuando sea posible (suele ser m√°s r√°pido)</li>
                            <li><strong>Alias</strong> descriptivos mejoran legibilidad: <code>c</code> para clientes, <code>p</code> para pedidos</li>
                            <li><code>LEFT JOIN</code> + <code>WHERE IS NULL</code> es el patr√≥n para "elementos sin relaci√≥n"</li>
                            <li>Usa <strong>IFNULL()</strong> o <strong>COALESCE()</strong> para manejar NULLs en c√°lculos</li>
                            <li><strong>GROUP_CONCAT()</strong> es √∫til para concatenar valores de un grupo</li>
                            <li><strong>CASE WHEN</strong> permite l√≥gica condicional dentro de SELECT</li>
                            <li>Siempre usa <code>LIMIT</code> cuando testeas queries nuevas en producci√≥n</li>
                            <li>Formatea queries complejas: una cl√°usula por l√≠nea, indenta subconsultas</li>
                            <li><strong>EXISTS</strong> puede ser m√°s r√°pido que <code>IN</code> con subconsultas grandes</li>
                        </ul>
                    </div>
                </section>

                <!-- NORMALIZACI√ìN -->
                <section id="normalizacion" class="content-section">
                    <h2 class="section-title">Normalizaci√≥n de Bases de Datos</h2>

                    <article class="topic">
                        <h3 class="topic-title">¬øQu√© es la Normalizaci√≥n?</h3>
                        <p class="topic-description">
                            La <strong>normalizaci√≥n</strong> es el proceso de organizar datos en una base de datos relacional para:
                        </p>
                        <ul class="topic-description">
                            <li><strong>Eliminar redundancia:</strong> No duplicar informaci√≥n innecesariamente</li>
                            <li><strong>Evitar anomal√≠as:</strong> Prevenir problemas al insertar, actualizar o eliminar datos</li>
                            <li><strong>Mantener integridad:</strong> Asegurar que los datos sean consistentes</li>
                            <li><strong>Facilitar mantenimiento:</strong> Hacer cambios en el esquema m√°s sencillos</li>
                        </ul>
                        <p class="topic-description">
                            Existen varias <strong>formas normales</strong>. Las m√°s importantes son: <strong>1FN, 2FN y 3FN</strong>.
                        </p>
                    </article>

                    <!-- Primera Forma Normal (1FN) -->
                    <article class="topic">
                        <h3 class="topic-title">Primera Forma Normal (1FN)</h3>
                        <p class="topic-description">
                            Una tabla est√° en <strong>1FN</strong> si:
                        </p>
                        <ul class="topic-description">
                            <li>Todos los valores son <strong>at√≥micos</strong> (indivisibles, un solo valor por celda)</li>
                            <li>No hay grupos repetidos de columnas</li>
                            <li>Cada fila es √∫nica (tiene clave primaria)</li>
                        </ul>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">‚ùå Tabla que NO cumple 1FN</span>
                            </div>
                            <pre><code class="language-sql">-- Problema: Columna "telefonos" contiene M√öLTIPLES valores (no at√≥mica)
    -- Problema: Columna "productos_comprados" es una lista

    CREATE TABLE pedidos_mal (
        id_pedido INT PRIMARY KEY,
        cliente VARCHAR(100),
        telefonos VARCHAR(200),           -- ‚ùå "666111222, 999888777" (m√∫ltiples valores)
        productos_comprados VARCHAR(500)  -- ‚ùå "Mouse, Teclado, Monitor" (m√∫ltiples valores)
    );

    -- Ejemplo de datos:
    -- +----------+-----------+-----------------------+---------------------------+
    -- | id_pedido| cliente   | telefonos            | productos_comprados       |
    -- +----------+-----------+-----------------------+---------------------------+
    -- | 1        | Ana       | 666111222, 999888777 | Mouse, Teclado, Monitor   |
    -- | 2        | Carlos    | 666333444            | Laptop                    |
    -- +----------+-----------+-----------------------+---------------------------+

    -- PROBLEMAS:
    -- 1. ¬øC√≥mo buscar clientes con un tel√©fono espec√≠fico? (dif√≠cil con LIKE)
    -- 2. ¬øC√≥mo contar cu√°ntos productos compr√≥ cada cliente? (imposible directamente)
    -- 3. ¬øC√≥mo actualizar el precio de "Mouse"? (no se puede relacionar con tabla productos)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">‚úÖ Tabla en 1FN - Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- Soluci√≥n 1FN: Crear tablas separadas con valores at√≥micos

    -- Tabla principal de pedidos
    CREATE TABLE pedidos (
        id_pedido INT PRIMARY KEY AUTO_INCREMENT,
        id_cliente INT,
        fecha_pedido DATE,
        FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
    );

    -- Tabla de clientes
    CREATE TABLE clientes (
        id_cliente INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100)
    );

    -- Tabla separada para tel√©fonos (relaci√≥n 1:N)
    CREATE TABLE telefonos_cliente (
        id_telefono INT PRIMARY KEY AUTO_INCREMENT,
        id_cliente INT,
        numero_telefono VARCHAR(15),  -- ‚úÖ Un solo valor por celda
        tipo ENUM('M√≥vil', 'Fijo'),
        FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
    );

    -- Tabla intermedia para productos comprados (relaci√≥n N:M)
    CREATE TABLE detalle_pedidos (
        id_detalle INT PRIMARY KEY AUTO_INCREMENT,
        id_pedido INT,
        id_producto INT,
        cantidad INT,
        FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido),
        FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
    );

    -- Ahora los datos son at√≥micos:
    -- clientes:
    -- +------------+--------+
    -- | id_cliente | nombre |
    -- +------------+--------+
    -- | 1          | Ana    |
    -- | 2          | Carlos |
    -- +------------+--------+

    -- telefonos_cliente:
    -- +-------------+------------+-----------------+--------+
    -- | id_telefono | id_cliente | numero_telefono | tipo   |
    -- +-------------+------------+-----------------+--------+
    -- | 1           | 1          | 666111222       | M√≥vil  |
    -- | 2           | 1          | 999888777       | Fijo   |
    -- | 3           | 2          | 666333444       | M√≥vil  |
    -- +-------------+------------+-----------------+--------+

    -- ‚úÖ Beneficios:
    -- 1. F√°cil buscar por tel√©fono: WHERE numero_telefono = '666111222'
    -- 2. F√°cil contar productos: COUNT en detalle_pedidos
    -- 3. Relaciones claras con FKs</code></pre>
                        </div>
                    </article>

                    <!-- Segunda Forma Normal (2FN) -->
                    <article class="topic">
                        <h3 class="topic-title">Segunda Forma Normal (2FN)</h3>
                        <p class="topic-description">
                            Una tabla est√° en <strong>2FN</strong> si:
                        </p>
                        <ul class="topic-description">
                            <li>Est√° en <strong>1FN</strong></li>
                            <li>Todos los atributos no clave dependen <strong>completamente</strong> de la clave primaria (no de parte de ella)</li>
                            <li>Solo aplica a tablas con <strong>clave primaria compuesta</strong> (m√∫ltiples columnas)</li>
                        </ul>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">‚ùå Tabla que NO cumple 2FN</span>
                            </div>
                            <pre><code class="language-sql">-- Tabla con clave primaria compuesta (id_pedido + id_producto)
    CREATE TABLE detalle_pedidos_mal (
        id_pedido INT,
        id_producto INT,
        cantidad INT,
        precio_unitario DECIMAL(10,2),
        nombre_producto VARCHAR(100),  -- ‚ùå Depende SOLO de id_producto (no de la clave completa)
        categoria VARCHAR(50),         -- ‚ùå Depende SOLO de id_producto
        nombre_cliente VARCHAR(100),   -- ‚ùå Depende SOLO de id_pedido
        PRIMARY KEY (id_pedido, id_producto)
    );

    -- Ejemplo de datos:
    -- +----------+------------+----------+------------------+-----------------+-----------+----------------+
    -- | id_pedido| id_producto| cantidad | precio_unitario  | nombre_producto | categoria | nombre_cliente |
    -- +----------+------------+----------+------------------+-----------------+-----------+----------------+
    -- | 1        | 101        | 2        | 25.50            | Mouse           | Hardware  | Ana            |
    -- | 1        | 102        | 1        | 89.99            | Teclado         | Hardware  | Ana            |  ‚Üê "Ana" duplicado
    -- | 2        | 101        | 1        | 25.50            | Mouse           | Hardware  | Carlos         |  ‚Üê "Mouse", "Hardware" duplicado
    -- +----------+------------+----------+------------------+-----------------+-----------+----------------+

    -- PROBLEMAS (Dependencias parciales):
    -- - nombre_producto depende SOLO de id_producto (no de id_pedido)
    -- - categoria depende SOLO de id_producto
    -- - nombre_cliente depende SOLO de id_pedido
    -- - REDUNDANCIA: "Mouse" y "Hardware" se repiten en m√∫ltiples filas
    -- - ANOMAL√çA DE ACTUALIZACI√ìN: Si cambio nombre de producto, debo actualizar TODAS las filas
    -- - ANOMAL√çA DE ELIMINACI√ìN: Si elimino todos los pedidos de un producto, pierdo info del producto</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">‚úÖ Tabla en 2FN - Soluci√≥n Paso a Paso</span>
                            </div>
                            <pre><code class="language-sql">-- PASO 1: Identificar dependencias
    -- En detalle_pedidos_mal:
    --   (id_pedido, id_producto) ‚Üí cantidad, precio_unitario  ‚úÖ Depende de clave completa
    --   id_producto ‚Üí nombre_producto, categoria              ‚ùå Dependencia PARCIAL
    --   id_pedido ‚Üí nombre_cliente                            ‚ùå Dependencia PARCIAL

    -- PASO 2: Separar en tablas distintas seg√∫n dependencias

    -- Tabla 1: Detalle de pedidos (solo lo que depende de AMBAS claves)
    CREATE TABLE detalle_pedidos (
        id_pedido INT,
        id_producto INT,
        cantidad INT,              -- ‚úÖ Depende de (id_pedido, id_producto)
        precio_unitario DECIMAL(10,2),  -- Precio en momento de compra
        PRIMARY KEY (id_pedido, id_producto),
        FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido),
        FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
    );

    -- Tabla 2: Productos (lo que depende SOLO de id_producto)
    CREATE TABLE productos (
        id_producto INT PRIMARY KEY,
        nombre_producto VARCHAR(100),  -- ‚úÖ Depende solo de id_producto
        categoria VARCHAR(50),          -- ‚úÖ Depende solo de id_producto
        precio_actual DECIMAL(10,2)
    );

    -- Tabla 3: Pedidos (lo que depende SOLO de id_pedido)
    CREATE TABLE pedidos (
        id_pedido INT PRIMARY KEY,
        id_cliente INT,
        fecha_pedido DATE,
        FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente)
    );

    -- Tabla 4: Clientes (lo que depende de id_cliente)
    CREATE TABLE clientes (
        id_cliente INT PRIMARY KEY,
        nombre_cliente VARCHAR(100)  -- ‚úÖ Sin redundancia
    );

    -- Ahora los datos:
    -- detalle_pedidos:
    -- +----------+------------+----------+-----------------+
    -- | id_pedido| id_producto| cantidad | precio_unitario |
    -- +----------+------------+----------+-----------------+
    -- | 1        | 101        | 2        | 25.50           |
    -- | 1        | 102        | 1        | 89.99           |
    -- | 2        | 101        | 1        | 25.50           |
    -- +----------+------------+----------+-----------------+

    -- productos:
    -- +------------+-----------------+-----------+
    -- | id_producto| nombre_producto | categoria |
    -- +------------+-----------------+-----------+
    -- | 101        | Mouse           | Hardware  |  ‚Üê UNA SOLA VEZ
    -- | 102        | Teclado         | Hardware  |
    -- +------------+-----------------+-----------+

    -- ‚úÖ Beneficios:
    -- - Sin redundancia: "Mouse" aparece UNA vez
    -- - Actualizar nombre producto: solo 1 UPDATE en tabla productos
    -- - Eliminar pedidos no afecta informaci√≥n de productos</code></pre>
                        </div>
                    </article>

                    <!-- Tercera Forma Normal (3FN) -->
                    <article class="topic">
                        <h3 class="topic-title">Tercera Forma Normal (3FN)</h3>
                        <p class="topic-description">
                            Una tabla est√° en <strong>3FN</strong> si:
                        </p>
                        <ul class="topic-description">
                            <li>Est√° en <strong>2FN</strong></li>
                            <li>No tiene <strong>dependencias transitivas</strong>: atributos no clave NO dependen de otros atributos no clave</li>
                            <li>Todos los atributos no clave dependen <strong>directamente</strong> de la clave primaria</li>
                        </ul>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">‚ùå Tabla que NO cumple 3FN (pero s√≠ 2FN)</span>
                            </div>
                            <pre><code class="language-sql">-- Tabla en 2FN pero NO en 3FN
    CREATE TABLE empleados_mal (
        id_empleado INT PRIMARY KEY,
        nombre VARCHAR(100),
        id_departamento INT,
        nombre_departamento VARCHAR(100),  -- ‚ùå Depende de id_departamento (no directamente de id_empleado)
        ubicacion_departamento VARCHAR(100) -- ‚ùå Depende de id_departamento (DEPENDENCIA TRANSITIVA)
    );

    -- Ejemplo de datos:
    -- +-------------+---------+----------------+----------------------+------------------------+
    -- | id_empleado | nombre  | id_departamento| nombre_departamento  | ubicacion_departamento |
    -- +-------------+---------+----------------+----------------------+------------------------+
    -- | 1           | Ana     | 10             | Ventas               | Edificio A             |
    -- | 2           | Carlos  | 10             | Ventas               | Edificio A             |  ‚Üê "Ventas", "Edificio A" duplicado
    -- | 3           | Mar√≠a   | 20             | IT                   | Edificio B             |
    -- | 4           | Juan    | 10             | Ventas               | Edificio A             |  ‚Üê Otra vez duplicado
    -- +-------------+---------+----------------+----------------------+------------------------+

    -- DEPENDENCIA TRANSITIVA:
    -- id_empleado ‚Üí id_departamento ‚Üí nombre_departamento
    -- id_empleado ‚Üí id_departamento ‚Üí ubicacion_departamento
    -- (nombre_departamento NO depende directamente de id_empleado, sino de id_departamento)

    -- PROBLEMAS:
    -- - REDUNDANCIA: "Ventas" y "Edificio A" se repiten para cada empleado del departamento
    -- - ANOMAL√çA DE ACTUALIZACI√ìN: Si el departamento cambia de edificio, debo actualizar TODOS los empleados
    -- - ANOMAL√çA DE INSERCI√ìN: No puedo crear un departamento sin empleados
    -- - ANOMAL√çA DE ELIMINACI√ìN: Si elimino todos los empleados, pierdo info del departamento</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">‚úÖ Tabla en 3FN - Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- PASO 1: Identificar dependencia transitiva
    -- id_empleado ‚Üí id_departamento (OK)
    -- id_departamento ‚Üí nombre_departamento, ubicacion_departamento (TRANSITIVA)

    -- PASO 2: Separar en tablas independientes

    -- Tabla 1: Empleados (solo lo que depende directamente de id_empleado)
    CREATE TABLE empleados (
        id_empleado INT PRIMARY KEY,
        nombre VARCHAR(100),
        id_departamento INT,  -- ‚úÖ FK, depende directamente de id_empleado
        salario DECIMAL(10,2),
        fecha_contratacion DATE,
        FOREIGN KEY (id_departamento) REFERENCES departamentos(id_departamento)
    );

    -- Tabla 2: Departamentos (informaci√≥n del departamento separada)
    CREATE TABLE departamentos (
        id_departamento INT PRIMARY KEY,
        nombre_departamento VARCHAR(100),  -- ‚úÖ Una sola vez por departamento
        ubicacion_departamento VARCHAR(100),
        presupuesto DECIMAL(12,2)
    );

    -- Datos normalizados:
    -- empleados:
    -- +-------------+---------+----------------+---------+-------------------+
    -- | id_empleado | nombre  | id_departamento| salario | fecha_contratacion|
    -- +-------------+---------+----------------+---------+-------------------+
    -- | 1           | Ana     | 10             | 2500.00 | 2023-01-15        |
    -- | 2           | Carlos  | 10             | 2800.00 | 2023-03-20        |
    -- | 3           | Mar√≠a   | 20             | 3200.00 | 2022-11-10        |
    -- | 4           | Juan    | 10             | 2600.00 | 2024-01-05        |
    -- +-------------+---------+----------------+---------+-------------------+

    -- departamentos:
    -- +----------------+---------------------+------------------------+-------------+
    -- | id_departamento| nombre_departamento | ubicacion_departamento | presupuesto |
    -- +----------------+---------------------+------------------------+-------------+
    -- | 10             | Ventas              | Edificio A             | 50000.00    |  ‚Üê UNA VEZ
    -- | 20             | IT                  | Edificio B             | 80000.00    |
    -- +----------------+---------------------+------------------------+-------------+

    -- ‚úÖ Beneficios:
    -- - Sin redundancia: info de "Ventas" aparece UNA vez
    -- - Cambiar ubicaci√≥n de departamento: solo 1 UPDATE en departamentos
    -- - Puedo tener departamentos sin empleados (para planificaci√≥n)
    -- - Eliminar empleados no afecta info de departamentos</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Consultar Datos Normalizados (con JOIN)</span>
                            </div>
                            <pre><code class="language-sql">-- Para obtener la misma vista que ten√≠amos antes, usamos JOIN:

    SELECT
        e.id_empleado,
        e.nombre,
        e.salario,
        d.nombre_departamento,
        d.ubicacion_departamento
    FROM empleados e
    INNER JOIN departamentos d ON e.id_departamento = d.id_departamento;

    -- Resultado (igual que antes, pero SIN redundancia en almacenamiento):
    -- +-------------+---------+---------+---------------------+------------------------+
    -- | id_empleado | nombre  | salario | nombre_departamento | ubicacion_departamento |
    -- +-------------+---------+---------+---------------------+------------------------+
    -- | 1           | Ana     | 2500.00 | Ventas              | Edificio A             |
    -- | 2           | Carlos  | 2800.00 | Ventas              | Edificio A             |
    -- | 3           | Mar√≠a   | 3200.00 | IT                  | Edificio B             |
    -- | 4           | Juan    | 2600.00 | Ventas              | Edificio A             |
    -- +-------------+---------+---------+---------------------+------------------------+</code></pre>
                        </div>
                    </article>

                    <!-- Ejemplo Completo de Normalizaci√≥n -->
                    <article class="topic">
                        <h3 class="topic-title">Ejemplo Completo: De NO Normalizado a 3FN</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Tabla Original (No Normalizada)</span>
                            </div>
                            <pre><code class="language-sql">-- Tabla sin normalizar: biblioteca
    CREATE TABLE biblioteca_sin_normalizar (
        id_prestamo INT,
        fecha_prestamo DATE,
        nombre_estudiante VARCHAR(100),
        email_estudiante VARCHAR(100),
        carrera VARCHAR(100),
        nombre_carrera_completo VARCHAR(200),  -- ‚ùå Depende de carrera
        libros_prestados VARCHAR(500),         -- ‚ùå M√∫ltiples valores (viola 1FN)
        autores VARCHAR(500),                  -- ‚ùå M√∫ltiples valores
        PRIMARY KEY (id_prestamo)
    );

    -- Datos:
    -- +------------+----------------+-------------------+-------------------+--------+------------------------+--------------------+--------------------+
    -- | id_prestamo| fecha_prestamo | nombre_estudiante | email_estudiante  | carrera| nombre_carrera_completo| libros_prestados   | autores            |
    -- +------------+----------------+-------------------+-------------------+--------+------------------------+--------------------+--------------------+
    -- | 1          | 2024-01-10     | Ana Garc√≠a        | ana@uni.edu       | DAM    | Des. Aplic. Multipl.   | SQL B√°sico, Java   | John Doe, Jane Roe |
    -- | 2          | 2024-01-15     | Carlos L√≥pez      | carlos@uni.edu    | DAW    | Des. Aplic. Web        | HTML5              | Mike Smith         |
    -- +------------+----------------+-------------------+-------------------+--------+------------------------+--------------------+--------------------+

    -- PROBLEMAS:
    -- ‚ùå Viola 1FN: libros_prestados y autores tienen m√∫ltiples valores
    -- ‚ùå Viola 3FN: nombre_carrera_completo depende de carrera (transitiva)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n Normalizada a 3FN</span>
                            </div>
                            <pre><code class="language-sql">-- PASO 1: Aplicar 1FN (valores at√≥micos)

    -- Tabla estudiantes
    CREATE TABLE estudiantes (
        id_estudiante INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100),
        email VARCHAR(100) UNIQUE,
        id_carrera INT,
        FOREIGN KEY (id_carrera) REFERENCES carreras(id_carrera)
    );

    -- Tabla carreras (elimina dependencia transitiva ‚Üí 3FN)
    CREATE TABLE carreras (
        id_carrera INT PRIMARY KEY AUTO_INCREMENT,
        siglas VARCHAR(10),
        nombre_completo VARCHAR(200)
    );

    -- Tabla libros
    CREATE TABLE libros (
        id_libro INT PRIMARY KEY AUTO_INCREMENT,
        titulo VARCHAR(200),
        isbn VARCHAR(20) UNIQUE,
        id_autor INT,
        FOREIGN KEY (id_autor) REFERENCES autores(id_autor)
    );

    -- Tabla autores
    CREATE TABLE autores (
        id_autor INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100)
    );

    -- Tabla pr√©stamos
    CREATE TABLE prestamos (
        id_prestamo INT PRIMARY KEY AUTO_INCREMENT,
        id_estudiante INT,
        fecha_prestamo DATE,
        fecha_devolucion DATE,
        FOREIGN KEY (id_estudiante) REFERENCES estudiantes(id_estudiante)
    );

    -- Tabla intermedia: detalle_prestamos (N:M entre prestamos y libros)
    CREATE TABLE detalle_prestamos (
        id_detalle INT PRIMARY KEY AUTO_INCREMENT,
        id_prestamo INT,
        id_libro INT,
        FOREIGN KEY (id_prestamo) REFERENCES prestamos(id_prestamo),
        FOREIGN KEY (id_libro) REFERENCES libros(id_libro),
        UNIQUE(id_prestamo, id_libro)  -- Un libro solo una vez por pr√©stamo
    );

    -- Insertar datos normalizados:

    -- Carreras
    INSERT INTO carreras (id_carrera, siglas, nombre_completo) VALUES
        (1, 'DAM', 'Desarrollo de Aplicaciones Multiplataforma'),
        (2, 'DAW', 'Desarrollo de Aplicaciones Web');

    -- Autores
    INSERT INTO autores (id_autor, nombre) VALUES
        (1, 'John Doe'),
        (2, 'Jane Roe'),
        (3, 'Mike Smith');

    -- Libros
    INSERT INTO libros (id_libro, titulo, isbn, id_autor) VALUES
        (1, 'SQL B√°sico', '978-1234567890', 1),
        (2, 'Java Avanzado', '978-1234567891', 2),
        (3, 'HTML5 Completo', '978-1234567892', 3);

    -- Estudiantes
    INSERT INTO estudiantes (id_estudiante, nombre, email, id_carrera) VALUES
        (1, 'Ana Garc√≠a', 'ana@uni.edu', 1),
        (2, 'Carlos L√≥pez', 'carlos@uni.edu', 2);

    -- Pr√©stamos
    INSERT INTO prestamos (id_prestamo, id_estudiante, fecha_prestamo) VALUES
        (1, 1, '2024-01-10'),
        (2, 2, '2024-01-15');

    -- Detalle de pr√©stamos
    INSERT INTO detalle_prestamos (id_prestamo, id_libro) VALUES
        (1, 1),  -- Ana prest√≥ SQL B√°sico
        (1, 2),  -- Ana prest√≥ Java Avanzado
        (2, 3);  -- Carlos prest√≥ HTML5

    -- ‚úÖ Ahora la base de datos est√° en 3FN:
    -- ‚úÖ 1FN: Todos los valores son at√≥micos
    -- ‚úÖ 2FN: No hay dependencias parciales (las claves compuestas est√°n en tablas intermedias)
    -- ‚úÖ 3FN: No hay dependencias transitivas (carreras es tabla separada)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Consulta para Reconstruir Vista Original</span>
                            </div>
                            <pre><code class="language-sql">-- Consulta con m√∫ltiples JOINs para obtener todos los datos:

    SELECT
        p.id_prestamo,
        p.fecha_prestamo,
        e.nombre AS estudiante,
        e.email,
        c.siglas AS carrera,
        c.nombre_completo AS nombre_carrera,
        GROUP_CONCAT(DISTINCT l.titulo SEPARATOR ', ') AS libros_prestados,
        GROUP_CONCAT(DISTINCT a.nombre SEPARATOR ', ') AS autores
    FROM prestamos p
    INNER JOIN estudiantes e ON p.id_estudiante = e.id_estudiante
    INNER JOIN carreras c ON e.id_carrera = c.id_carrera
    INNER JOIN detalle_prestamos dp ON p.id_prestamo = dp.id_prestamo
    INNER JOIN libros l ON dp.id_libro = l.id_libro
    INNER JOIN autores a ON l.id_autor = a.id_autor
    GROUP BY p.id_prestamo, p.fecha_prestamo, e.nombre, e.email, c.siglas, c.nombre_completo
    ORDER BY p.fecha_prestamo;

    -- Resultado (vista igual que tabla original, pero datos normalizados):
    -- +------------+----------------+--------------+-----------------+--------+-------------------------------+-------------------------+--------------------+
    -- | id_prestamo| fecha_prestamo | estudiante   | email           | carrera| nombre_carrera                | libros_prestados        | autores            |
    -- +------------+----------------+--------------+-----------------+--------+-------------------------------+-------------------------+--------------------+
    -- | 1          | 2024-01-10     | Ana Garc√≠a   | ana@uni.edu     | DAM    | Des. Aplic. Multiplataforma   | SQL B√°sico, Java Avanza | John Doe, Jane Roe |
    -- | 2          | 2024-01-15     | Carlos L√≥pez | carlos@uni.edu  | DAW    | Des. Aplic. Web               | HTML5 Completo          | Mike Smith         |
    -- +------------+----------------+--------------+-----------------+--------+-------------------------------+-------------------------+--------------------+</code></pre>
                        </div>
                    </article>

                    <!-- Resumen de Formas Normales -->
                    <article class="topic">
                        <h3 class="topic-title">Resumen de Formas Normales</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Cheatsheet: 1FN, 2FN, 3FN</span>
                            </div>
                            <pre><code class="language-sql">-- ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    -- ‚îÇ FORMA NORMAL ‚îÇ REQUISITOS                                           ‚îÇ
    -- ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    -- ‚îÇ 1FN          ‚îÇ - Valores at√≥micos (un solo dato por celda)          ‚îÇ
    -- ‚îÇ              ‚îÇ - Sin grupos repetidos                               ‚îÇ
    -- ‚îÇ              ‚îÇ - Clave primaria definida                            ‚îÇ
    -- ‚îÇ              ‚îÇ Soluci√≥n: Crear tablas separadas para valores m√∫lt. ‚îÇ
    -- ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    -- ‚îÇ 2FN          ‚îÇ - Cumple 1FN                                          ‚îÇ
    -- ‚îÇ              ‚îÇ - Sin dependencias PARCIALES de clave compuesta      ‚îÇ
    -- ‚îÇ              ‚îÇ - Todos atributos dependen de TODA la clave          ‚îÇ
    -- ‚îÇ              ‚îÇ Soluci√≥n: Separar en tablas seg√∫n dependencias       ‚îÇ
    -- ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    -- ‚îÇ 3FN          ‚îÇ - Cumple 2FN                                          ‚îÇ
    -- ‚îÇ              ‚îÇ - Sin dependencias TRANSITIVAS                       ‚îÇ
    -- ‚îÇ              ‚îÇ - Atributos no clave NO dependen entre s√≠            ‚îÇ
    -- ‚îÇ              ‚îÇ Soluci√≥n: Extraer atributos dependientes a nueva tabla‚îÇ
    -- ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    -- EJEMPLO R√ÅPIDO:
    -- Tabla: Pedidos (id_pedido, id_producto, cantidad, nombre_producto, categoria_producto)
    --
    -- ‚ùå Viola 2FN: nombre_producto y categoria_producto dependen SOLO de id_producto
    --
    -- ‚úÖ Soluci√≥n:
    -- - pedidos (id_pedido, id_producto, cantidad)
    -- - productos (id_producto, nombre_producto, categoria_producto)</code></pre>
                        </div>
                    </article>

                    <!-- Errores Comunes -->
                    <div class="error-box">
                        <div class="error-title">‚ö†Ô∏è Errores Comunes en Normalizaci√≥n</div>
                        <ul class="error-list">
                            <li><strong>Sobre-normalizaci√≥n:</strong> Dividir DEMASIADO puede hacer queries muy complejas. Encuentra el balance.</li>
                            <li><strong>Olvidar FKs:</strong> Al separar tablas, SIEMPRE crea Foreign Keys para mantener integridad</li>
                            <li><strong>No identificar dependencias transitivas:</strong> Revisa si columna A ‚Üí columna B ‚Üí columna C</li>
                            <li><strong>Confundir 2FN y 3FN:</strong> 2FN es para claves compuestas, 3FN es para dependencias entre no-claves</li>
                            <li><strong>Valores separados por comas:</strong> "Item1, Item2" en una columna SIEMPRE viola 1FN</li>
                            <li><strong>Duplicar datos en vez de usar relaciones:</strong> Si repites info, probablemente necesitas otra tabla</li>
                        </ul>
                    </div>

                    <!-- Pro Tips -->
                    <div class="tip-box">
                        <div class="tip-title">üí° Pro Tips - Normalizaci√≥n</div>
                        <ul class="tip-list">
                            <li><strong>Regla de oro:</strong> Si repites datos, normaliza. Cada dato debe estar en UN solo lugar.</li>
                            <li>La normalizaci√≥n <strong>reduce espacio</strong> pero puede <strong>aumentar complejidad de queries</strong> (m√°s JOINs)</li>
                            <li>Para aplicaciones de <strong>lectura intensiva</strong>, a veces se <strong>desnormaliza</strong> intencionalmente (cach√©, reporting)</li>
                            <li>Usa <strong>diagramas E-R</strong> antes de implementar para visualizar relaciones</li>
                            <li>Las tablas <strong>intermedias</strong> (N:M) suelen tener clave compuesta ‚Üí verifica 2FN</li>
                            <li><strong>3FN es suficiente</strong> para la mayor√≠a de aplicaciones. BCNF y 4FN son raramente necesarias.</li>
                            <li>Preg√∫ntate: "¬øSi actualizo dato X, debo tocar m√∫ltiples filas?" ‚Üí Si s√≠, normaliza m√°s</li>
                            <li>Normaliza en dise√±o; considera <strong>vistas</strong> o <strong>procedures</strong> para queries complejas frecuentes</li>
                        </ul>
                    </div>
                </section>

                <!-- √çNDICES Y OPTIMIZACI√ìN -->
                <section id="indices" class="content-section">
                    <h2 class="section-title">√çndices y Optimizaci√≥n</h2>

                    <article class="topic">
                        <h3 class="topic-title">¬øQu√© son los √çndices?</h3>
                        <p class="topic-description">
                            Un <strong>√≠ndice</strong> es una estructura de datos que mejora la velocidad de las consultas en una tabla.
                            Funciona como el √≠ndice de un libro: en vez de leer todo el libro para encontrar un tema,
                            vas directamente a la p√°gina indicada.
                        </p>
                        <ul class="topic-description">
                            <li><strong>Ventaja:</strong> Consultas SELECT mucho m√°s r√°pidas (especialmente con WHERE, JOIN, ORDER BY)</li>
                            <li><strong>Desventaja:</strong> Ralentiza INSERT, UPDATE, DELETE (el √≠ndice debe actualizarse)</li>
                            <li><strong>Espacio:</strong> Los √≠ndices ocupan espacio adicional en disco</li>
                        </ul>
                        <p class="topic-description">
                            MySQL crea autom√°ticamente √≠ndices para <code>PRIMARY KEY</code> y <code>UNIQUE</code>.
                            T√∫ puedes crear √≠ndices adicionales en columnas que usas frecuentemente en b√∫squedas.
                        </p>
                    </article>

                    <!-- Crear √çndices -->
                    <article class="topic">
                        <h3 class="topic-title">Crear y Gestionar √çndices</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Sintaxis de CREATE INDEX</span>
                            </div>
                            <pre><code class="language-sql">-- Crear √≠ndice simple en una columna
    CREATE INDEX nombre_indice ON tabla(columna);

    -- Crear √≠ndice compuesto (m√∫ltiples columnas)
    CREATE INDEX nombre_indice ON tabla(columna1, columna2);

    -- Crear √≠ndice UNIQUE (valores √∫nicos)
    CREATE UNIQUE INDEX nombre_indice ON tabla(columna);

    -- Ver √≠ndices de una tabla
    SHOW INDEX FROM tabla;

    -- Eliminar √≠ndice
    DROP INDEX nombre_indice ON tabla;

    -- Alternativamente, con ALTER TABLE:
    ALTER TABLE tabla ADD INDEX nombre_indice (columna);
    ALTER TABLE tabla DROP INDEX nombre_indice;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo Pr√°ctico: Tabla de Usuarios</span>
                            </div>
                            <pre><code class="language-sql">-- Crear tabla de usuarios
    CREATE TABLE usuarios (
        id_usuario INT PRIMARY KEY AUTO_INCREMENT,  -- √çndice autom√°tico en PK
        email VARCHAR(100) UNIQUE,                  -- √çndice autom√°tico en UNIQUE
        nombre VARCHAR(100),
        apellido VARCHAR(100),
        fecha_nacimiento DATE,
        ciudad VARCHAR(50),
        pais VARCHAR(50),
        activo BOOLEAN DEFAULT TRUE,
        fecha_registro DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    -- Insertar datos de prueba (1000 usuarios simulados)
    INSERT INTO usuarios (email, nombre, apellido, fecha_nacimiento, ciudad, pais, activo)
    VALUES
        ('ana@email.com', 'Ana', 'Garc√≠a', '1995-03-15', 'Madrid', 'Espa√±a', TRUE),
        ('carlos@email.com', 'Carlos', 'L√≥pez', '1988-07-22', 'Barcelona', 'Espa√±a', TRUE),
        -- ... (imagina 1000 usuarios m√°s)
        ('user999@email.com', 'Usuario', 'Test', '2000-01-01', 'Valencia', 'Espa√±a', FALSE);

    -- Query SIN √≠ndice en apellido (LENTA con miles de registros)
    SELECT * FROM usuarios WHERE apellido = 'Garc√≠a';
    -- MySQL debe hacer un FULL TABLE SCAN (leer TODAS las filas)

    -- Crear √≠ndice en apellido
    CREATE INDEX idx_apellido ON usuarios(apellido);

    -- Ahora la misma query es MUCHO m√°s r√°pida
    SELECT * FROM usuarios WHERE apellido = 'Garc√≠a';
    -- MySQL usa el √≠ndice para ir directamente a filas con apellido 'Garc√≠a'</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">√çndices Compuestos (M√∫ltiples Columnas)</span>
                            </div>
                            <pre><code class="language-sql">-- Si buscas frecuentemente por ciudad Y pa√≠s juntos:
    SELECT * FROM usuarios WHERE ciudad = 'Madrid' AND pais = 'Espa√±a';

    -- Crear √≠ndice compuesto (orden importa: ciudad primero, pais segundo)
    CREATE INDEX idx_ubicacion ON usuarios(ciudad, pais);

    -- Este √≠ndice AYUDA en estas queries:
    SELECT * FROM usuarios WHERE ciudad = 'Madrid' AND pais = 'Espa√±a';  -- ‚úÖ Usa √≠ndice completo
    SELECT * FROM usuarios WHERE ciudad = 'Madrid';                      -- ‚úÖ Usa parte del √≠ndice (ciudad)

    -- Pero NO ayuda en esta query:
    SELECT * FROM usuarios WHERE pais = 'Espa√±a';  -- ‚ùå No usa √≠ndice (pais est√° segundo)

    -- REGLA: Un √≠ndice compuesto (col1, col2, col3) se usa si la query filtra por:
    -- - col1
    -- - col1 y col2
    -- - col1, col2 y col3
    -- Pero NO si filtra solo por col2 o solo por col3

    -- √çndice para b√∫squedas frecuentes por apellido + nombre
    CREATE INDEX idx_nombre_completo ON usuarios(apellido, nombre);

    -- Optimiza:
    SELECT * FROM usuarios WHERE apellido = 'Garc√≠a' AND nombre = 'Ana';  -- ‚úÖ
    SELECT * FROM usuarios WHERE apellido = 'Garc√≠a';                     -- ‚úÖ</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ver √çndices Existentes</span>
                            </div>
                            <pre><code class="language-sql">-- Ver todos los √≠ndices de una tabla
    SHOW INDEX FROM usuarios;

    -- Resultado muestra:
    -- Table    | Non_unique | Key_name          | Column_name | Cardinality
    -- usuarios | 0          | PRIMARY           | id_usuario  | 1000
    -- usuarios | 0          | email             | email       | 1000
    -- usuarios | 1          | idx_apellido      | apellido    | 250
    -- usuarios | 1          | idx_ubicacion     | ciudad      | 50
    -- usuarios | 1          | idx_ubicacion     | pais        | 10
    -- usuarios | 1          | idx_nombre_completo| apellido   | 250
    -- usuarios | 1          | idx_nombre_completo| nombre     | 800

    -- Non_unique = 0 significa UNIQUE (PRIMARY KEY o UNIQUE constraint)
    -- Cardinality = estimaci√≥n de valores √∫nicos (m√°s alto = m√°s selectivo = mejor √≠ndice)</code></pre>
                        </div>
                    </article>

                    <!-- EXPLAIN - Analizar Queries -->
                    <article class="topic">
                        <h3 class="topic-title">EXPLAIN - Analizar el Plan de Ejecuci√≥n</h3>
                        <p class="topic-description">
                            <strong>EXPLAIN</strong> muestra c√≥mo MySQL ejecutar√° una query.
                            Es la herramienta m√°s importante para <strong>optimizaci√≥n</strong>.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Usar EXPLAIN</span>
                            </div>
                            <pre><code class="language-sql">-- Sintaxis: A√±adir EXPLAIN antes de SELECT
    EXPLAIN SELECT * FROM usuarios WHERE apellido = 'Garc√≠a';

    -- Resultado (columnas importantes):
    -- +----+-------------+----------+------+---------------+--------------+---------+-------+------+-------------+
    -- | id | select_type | table    | type | possible_keys | key          | key_len | ref   | rows | Extra       |
    -- +----+-------------+----------+------+---------------+--------------+---------+-------+------+-------------+
    -- | 1  | SIMPLE      | usuarios | ref  | idx_apellido  | idx_apellido | 103     | const | 50   | Using where |
    -- +----+-------------+----------+------+---------------+--------------+---------+-------+------+-------------+

    -- COLUMNAS CLAVE:
    -- - type: Tipo de acceso (de MEJOR a PEOR):
    --   * const: Una sola fila (b√∫squeda por PRIMARY KEY con constante)
    --   * eq_ref: Una fila por cada fila de tabla anterior (JOINs con PRIMARY KEY/UNIQUE)
    --   * ref: M√∫ltiples filas con valor igual (√≠ndice no √∫nico)
    --   * range: Rango de filas (WHERE con >, <, BETWEEN, IN)
    --   * index: Full index scan (lee todo el √≠ndice, no la tabla)
    --   * ALL: ‚ùå Full table scan (lee TODA la tabla, MUY LENTO)
    --
    -- - possible_keys: √çndices que MySQL PODR√çA usar
    -- - key: √çndice que MySQL REALMENTE usa (NULL = no usa √≠ndice)
    -- - rows: Estimaci√≥n de filas que debe examinar (cuanto menor, mejor)
    -- - Extra: Informaci√≥n adicional:
    --   * Using index: ‚úÖ Query cubierta por √≠ndice (muy r√°pido)
    --   * Using where: Filtra filas con WHERE
    --   * Using temporary: ‚ùå Usa tabla temporal (lento)
    --   * Using filesort: ‚ùå Ordena en disco (lento con muchos datos)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo: Optimizar Query Lenta</span>
                            </div>
                            <pre><code class="language-sql">-- Query inicial (SIN √≠ndice en fecha_registro)
    EXPLAIN SELECT * FROM usuarios
    WHERE fecha_registro > '2024-01-01'
    ORDER BY fecha_registro DESC;

    -- Resultado:
    -- type: ALL  ‚ùå (full table scan)
    -- key: NULL  ‚ùå (no usa √≠ndice)
    -- rows: 1000 ‚ùå (examina todas las filas)
    -- Extra: Using where; Using filesort  ‚ùå (ordena en disco)

    -- SOLUCI√ìN: Crear √≠ndice en fecha_registro
    CREATE INDEX idx_fecha_registro ON usuarios(fecha_registro);

    -- Ahora EXPLAIN muestra:
    -- type: range ‚úÖ (usa rango del √≠ndice)
    -- key: idx_fecha_registro ‚úÖ (usa el nuevo √≠ndice)
    -- rows: 300 ‚úÖ (solo examina filas necesarias)
    -- Extra: Using where ‚úÖ (sin filesort, el √≠ndice ya est√° ordenado)

    -- RESULTADO: Query 10x-100x m√°s r√°pida</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">EXPLAIN con JOINs</span>
                            </div>
                            <pre><code class="language-sql">-- Crear tablas relacionadas
    CREATE TABLE pedidos (
        id_pedido INT PRIMARY KEY AUTO_INCREMENT,
        id_usuario INT,
        fecha_pedido DATE,
        total DECIMAL(10,2),
        FOREIGN KEY (id_usuario) REFERENCES usuarios(id_usuario)
    );

    -- Query con JOIN
    EXPLAIN SELECT
        u.nombre,
        u.apellido,
        p.id_pedido,
        p.total
    FROM usuarios u
    INNER JOIN pedidos p ON u.id_usuario = p.id_usuario
    WHERE u.ciudad = 'Madrid';

    -- Resultado analiza AMBAS tablas:
    -- +----+-------------+-------+------+---------------+------+---------+------------------+------+-------------+
    -- | id | select_type | table | type | possible_keys | key  | key_len | ref              | rows | Extra       |
    -- +----+-------------+-------+------+---------------+------+---------+------------------+------+-------------+
    -- | 1  | SIMPLE      | u     | ref  | PRIMARY,idx.. | idx..| 53      | const            | 100  | Using where |
    -- | 1  | SIMPLE      | p     | ref  | id_usuario    | id_. | 5       | db.u.id_usuario  | 5    |             |
    -- +----+-------------+-------+------+---------------+------+---------+------------------+------+-------------+

    -- INTERPRETACI√ìN:
    -- 1. MySQL primero busca en usuarios (u) con ciudad = 'Madrid' ‚Üí 100 filas
    -- 2. Por cada usuario encontrado, busca sus pedidos (p) ‚Üí 5 pedidos promedio
    -- 3. Total filas procesadas: 100 * 5 = 500 (estimado)

    -- Si idx_ubicacion no existiera en usuarios:
    -- - Tipo ser√≠a ALL (full scan de 1000 usuarios)
    -- - Total filas: 1000 * 5 = 5000 (10x peor)</code></pre>
                        </div>
                    </article>

                    <!-- Cu√°ndo usar √≠ndices -->
                    <article class="topic">
                        <h3 class="topic-title">Cu√°ndo Usar √çndices</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">S√ç crear √≠ndices en:</span>
                            </div>
                            <pre><code class="language-sql">-- ‚úÖ Columnas en WHERE frecuentes
    CREATE INDEX idx_activo ON usuarios(activo);
    SELECT * FROM usuarios WHERE activo = TRUE;  -- Mucho m√°s r√°pido

    -- ‚úÖ Columnas en JOIN
    CREATE INDEX idx_usuario_pedidos ON pedidos(id_usuario);
    SELECT * FROM usuarios u
    INNER JOIN pedidos p ON u.id_usuario = p.id_usuario;  -- JOIN m√°s r√°pido

    -- ‚úÖ Columnas en ORDER BY
    CREATE INDEX idx_fecha ON pedidos(fecha_pedido);
    SELECT * FROM pedidos ORDER BY fecha_pedido DESC LIMIT 10;  -- Sin filesort

    -- ‚úÖ Columnas en GROUP BY
    CREATE INDEX idx_ciudad ON usuarios(ciudad);
    SELECT ciudad, COUNT(*) FROM usuarios GROUP BY ciudad;  -- M√°s r√°pido

    -- ‚úÖ Columnas con alta cardinalidad (muchos valores √∫nicos)
    CREATE INDEX idx_email ON usuarios(email);  -- Email es casi siempre √∫nico
    -- Cardinalidad alta = √≠ndice m√°s efectivo</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">NO crear √≠ndices en:</span>
                            </div>
                            <pre><code class="language-sql">-- ‚ùå Tablas peque√±as (< 1000 filas)
    -- Full table scan es m√°s r√°pido que usar √≠ndice en tablas chicas

    -- ‚ùå Columnas con baja cardinalidad (pocos valores distintos)
    -- Ejemplo: columna 'sexo' (solo 'M' o 'F')
    CREATE INDEX idx_sexo ON usuarios(sexo);  -- ‚ùå MALO
    -- Con solo 2 valores, √≠ndice no ayuda mucho (examinar√≠a ~50% de tabla igual)

    -- ‚ùå Columnas que cambian frecuentemente
    -- Si haces muchos UPDATE en una columna, el √≠ndice se actualiza constantemente
    -- Ejemplo: columna 'visitas' que se incrementa en cada acceso

    -- ‚ùå Columnas que nunca usas en WHERE, JOIN, ORDER BY o GROUP BY
    CREATE INDEX idx_descripcion ON productos(descripcion);  -- ‚ùå Si nunca buscas por descripci√≥n

    -- ‚ùå Demasiados √≠ndices en una tabla
    -- Cada √≠ndice ralentiza INSERT/UPDATE/DELETE
    -- Regla general: m√°ximo 5-7 √≠ndices por tabla (depende del caso)</code></pre>
                        </div>
                    </article>

                    <!-- Optimizaci√≥n de Queries -->
                    <article class="topic">
                        <h3 class="topic-title">T√©cnicas de Optimizaci√≥n</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">1. Selecciona solo columnas necesarias</span>
                            </div>
                            <pre><code class="language-sql">-- ‚ùå MALO: Seleccionar todo
    SELECT * FROM usuarios WHERE ciudad = 'Madrid';
    -- Transfiere TODAS las columnas (incluyendo campos grandes como descripci√≥n)

    -- ‚úÖ BUENO: Solo lo que necesitas
    SELECT id_usuario, nombre, email FROM usuarios WHERE ciudad = 'Madrid';
    -- Menos datos transferidos = m√°s r√°pido

    -- ‚úÖ MUY BUENO: Query cubierta por √≠ndice (Covering Index)
    CREATE INDEX idx_ciudad_nombre ON usuarios(ciudad, nombre, email);
    SELECT nombre, email FROM usuarios WHERE ciudad = 'Madrid';
    -- MySQL obtiene TODOS los datos del √≠ndice, sin acceder a la tabla (Extra: Using index)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">2. Evita funciones en columnas de WHERE</span>
                            </div>
                            <pre><code class="language-sql">-- ‚ùå MALO: Funci√≥n en columna indexada (√≠ndice NO se usa)
    SELECT * FROM pedidos WHERE YEAR(fecha_pedido) = 2024;
    -- MySQL debe ejecutar YEAR() en TODAS las filas (full scan)

    -- ‚úÖ BUENO: Comparaci√≥n directa (√≠ndice S√ç se usa)
    SELECT * FROM pedidos
    WHERE fecha_pedido >= '2024-01-01' AND fecha_pedido < '2025-01-01';
    -- MySQL usa el √≠ndice en fecha_pedido

    -- Otro ejemplo:
    -- ‚ùå MALO
    SELECT * FROM usuarios WHERE UPPER(email) = 'ANA@EMAIL.COM';

    -- ‚úÖ BUENO
    SELECT * FROM usuarios WHERE email = 'ana@email.com';
    -- Guarda emails en min√∫sculas en la BD, busca en min√∫sculas</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">3. Usa LIMIT en queries grandes</span>
                            </div>
                            <pre><code class="language-sql">-- Si solo necesitas algunos resultados:
    SELECT * FROM usuarios ORDER BY fecha_registro DESC LIMIT 10;
    -- MySQL se detiene despu√©s de encontrar 10 filas

    -- Para paginaci√≥n:
    SELECT * FROM usuarios ORDER BY id_usuario LIMIT 100 OFFSET 200;
    -- Muestra usuarios 201-300

    -- ‚ö†Ô∏è CUIDADO con OFFSET alto:
    SELECT * FROM usuarios LIMIT 10 OFFSET 100000;  -- ‚ùå LENTO
    -- MySQL debe leer y saltar 100000 filas primero

    -- ‚úÖ MEJOR: Paginaci√≥n basada en cursor
    SELECT * FROM usuarios WHERE id_usuario > 100000 ORDER BY id_usuario LIMIT 10;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">4. Optimiza JOINs</span>
                            </div>
                            <pre><code class="language-sql">-- ‚úÖ Aseg√∫rate de que columnas de JOIN tienen √≠ndices
    -- MySQL YA crea √≠ndice en id_usuario (PK) en usuarios
    -- Pero debes crear √≠ndice en FK:
    CREATE INDEX idx_id_usuario ON pedidos(id_usuario);

    -- ‚úÖ Filtra lo m√°s posible antes de JOIN
    -- MALO:
    SELECT * FROM usuarios u
    INNER JOIN pedidos p ON u.id_usuario = p.id_usuario
    WHERE u.ciudad = 'Madrid';  -- Filtra despu√©s del JOIN

    -- MEJOR (aunque MySQL optimiza autom√°ticamente):
    -- En la pr√°ctica, MySQL reordena y ejecuta WHERE primero,
    -- pero ayuda que sea expl√≠cito en subconsultas

    -- ‚úÖ Usa el tipo de JOIN correcto
    -- INNER JOIN: Solo filas con coincidencia (m√°s r√°pido)
    -- LEFT JOIN: Todas de tabla izquierda + coincidencias (m√°s lento)
    -- Si sabes que TODOS los pedidos tienen usuario, usa INNER</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">5. Evita subconsultas en SELECT cuando sea posible</span>
                            </div>
                            <pre><code class="language-sql">-- ‚ùå LENTO: Subconsulta correlacionada en SELECT
    SELECT
        u.nombre,
        (SELECT COUNT(*) FROM pedidos p WHERE p.id_usuario = u.id_usuario) AS num_pedidos
    FROM usuarios u;
    -- Ejecuta la subconsulta POR CADA usuario (N queries)

    -- ‚úÖ R√ÅPIDO: JOIN + GROUP BY
    SELECT
        u.nombre,
        COUNT(p.id_pedido) AS num_pedidos
    FROM usuarios u
    LEFT JOIN pedidos p ON u.id_usuario = p.id_usuario
    GROUP BY u.id_usuario, u.nombre;
    -- Una sola query con JOIN (mucho m√°s eficiente)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">6. Usa EXISTS en vez de IN para subconsultas grandes</span>
                            </div>
                            <pre><code class="language-sql">-- Si la subconsulta devuelve MUCHOS resultados:

    -- ‚ùå Puede ser lento con muchos resultados
    SELECT * FROM usuarios
    WHERE id_usuario IN (SELECT id_usuario FROM pedidos WHERE total > 100);
    -- MySQL eval√∫a toda la subconsulta primero

    -- ‚úÖ Generalmente m√°s r√°pido
    SELECT * FROM usuarios u
    WHERE EXISTS (
        SELECT 1 FROM pedidos p
        WHERE p.id_usuario = u.id_usuario AND p.total > 100
    );
    -- EXISTS se detiene en el primer match (short-circuit)</code></pre>
                        </div>
                    </article>

                    <!-- Analizar Rendimiento -->
                    <article class="topic">
                        <h3 class="topic-title">Herramientas de An√°lisis</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Analizar Uso de Tablas e √çndices</span>
                            </div>
                            <pre><code class="language-sql">-- Ver tama√±o de tablas
    SELECT
        table_name,
        ROUND(((data_length + index_length) / 1024 / 1024), 2) AS size_mb,
        table_rows
    FROM information_schema.tables
    WHERE table_schema = 'nombre_base_datos'
    ORDER BY (data_length + index_length) DESC;

    -- Ver estad√≠sticas de √≠ndices
    SHOW INDEX FROM usuarios;

    -- Ver queries lentas (si slow query log est√° activado)
    -- Configura en my.cnf:
    -- slow_query_log = 1
    -- long_query_time = 2  (queries > 2 segundos)
    -- slow_query_log_file = /var/log/mysql/slow.log

    -- Analizar tabla (actualiza estad√≠sticas)
    ANALYZE TABLE usuarios;

    -- Optimizar tabla (desfragmenta y reorganiza)
    OPTIMIZE TABLE usuarios;</code></pre>
                        </div>
                    </article>

                    <!-- Errores Comunes -->
                    <div class="error-box">
                        <div class="error-title">‚ö†Ô∏è Errores Comunes en √çndices y Optimizaci√≥n</div>
                        <ul class="error-list">
                            <li><strong>Crear √≠ndices en TODAS las columnas:</strong> M√°s √≠ndices = m√°s lento INSERT/UPDATE/DELETE. Solo crea √≠ndices necesarios.</li>
                            <li><strong>No usar EXPLAIN:</strong> Siempre analiza queries lentas con EXPLAIN antes de a√±adir √≠ndices.</li>
                            <li><strong>√çndices en columnas con pocos valores distintos:</strong> Ej: columna 'activo' (TRUE/FALSE) raramente beneficia de √≠ndice.</li>
                            <li><strong>Usar SELECT * en producci√≥n:</strong> Especifica columnas necesarias para reducir transferencia de datos.</li>
                            <li><strong>Olvidar √≠ndices en FKs:</strong> Siempre indexa columnas que usas en JOINs (especialmente Foreign Keys).</li>
                            <li><strong>WHERE con funciones:</strong> <code>WHERE YEAR(fecha) = 2024</code> no usa √≠ndice. Usa rangos directos.</li>
                            <li><strong>No considerar el orden en √≠ndices compuestos:</strong> El orden de columnas importa.</li>
                        </ul>
                    </div>

                    <!-- Pro Tips -->
                    <div class="tip-box">
                        <div class="tip-title">üí° Pro Tips - √çndices y Optimizaci√≥n</div>
                        <ul class="tip-list">
                            <li><strong>Regla 80/20:</strong> El 80% de queries usa el 20% de columnas. Indexa ese 20%.</li>
                            <li>Un <strong>√≠ndice compuesto (A, B, C)</strong> funciona para b√∫squedas por A, por A+B, y por A+B+C (pero NO solo B o C).</li>
                            <li><strong>Covering Index:</strong> Si el √≠ndice contiene TODAS las columnas de SELECT, MySQL ni siquiera lee la tabla (rapid√≠simo).</li>
                            <li>Usa <code>EXPLAIN</code> antes de optimizar. No adivines, <strong>mide</strong>.</li>
                            <li><strong>PRIMARY KEY</strong> debe ser: peque√±o (INT mejor que VARCHAR), AUTO_INCREMENT, inmutable.</li>
                            <li>Para b√∫squedas de texto, considera <strong>FULLTEXT INDEX</strong> en vez de <code>LIKE '%texto%'</code>.</li>
                            <li><strong>√çndices en desarrollo ‚â† producci√≥n:</strong> Con 100 filas todo es r√°pido. Problemas aparecen con 100,000+.</li>
                            <li>Reconstruye √≠ndices peri√≥dicamente con <code>OPTIMIZE TABLE</code> (especialmente tras muchos DELETE).</li>
                            <li>MySQL tiene <strong>query cache</strong> (en versiones antiguas). Queries id√©nticas se sirven de cach√©.</li>
                            <li><strong>Monitorea slow query log</strong> en producci√≥n para identificar queries problem√°ticas.</li>
                        </ul>
                    </div>
                </section>

                <!-- TRANSACCIONES -->
                <section id="transacciones" class="content-section">
                    <h2 class="section-title">Transacciones</h2>

                    <article class="topic">
                        <h3 class="topic-title">¬øQu√© es una Transacci√≥n?</h3>
                        <p class="topic-description">
                            Una <strong>transacci√≥n</strong> es un conjunto de operaciones SQL que se ejecutan como una <strong>unidad at√≥mica</strong>:
                            o se ejecutan TODAS con √©xito, o NO se ejecuta NINGUNA.
                        </p>
                        <p class="topic-description">
                            <strong>Ejemplo del mundo real:</strong> Transferencia bancaria entre dos cuentas:
                        </p>
                        <ul class="topic-description">
                            <li>Paso 1: Restar dinero de cuenta A</li>
                            <li>Paso 2: Sumar dinero a cuenta B</li>
                        </ul>
                        <p class="topic-description">
                            Si el paso 1 funciona pero el paso 2 falla (error de red, ca√≠da del servidor), el dinero desaparece.
                            <strong>Transacciones</strong> garantizan que AMBOS pasos ocurran o NINGUNO.
                        </p>
                    </article>

                    <!-- Propiedades ACID -->
                    <article class="topic">
                        <h3 class="topic-title">Propiedades ACID</h3>
                        <p class="topic-description">
                            Las transacciones deben cumplir 4 propiedades conocidas como <strong>ACID</strong>:
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">ACID - Definici√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- A - ATOMICITY (Atomicidad)
    -- La transacci√≥n es indivisible: TODO o NADA
    -- Si una operaci√≥n falla, se revierten TODAS las anteriores

    -- C - CONSISTENCY (Consistencia)
    -- La BD pasa de un estado v√°lido a otro estado v√°lido
    -- No se violan constraints (PRIMARY KEY, FOREIGN KEY, CHECK, etc.)

    -- I - ISOLATION (Aislamiento)
    -- Transacciones concurrentes no interfieren entre s√≠
    -- Cada transacci√≥n act√∫a como si fuera la √∫nica ejecut√°ndose

    -- D - DURABILITY (Durabilidad)
    -- Una vez hecho COMMIT, los cambios son PERMANENTES
    -- Sobreviven a fallos del sistema (crash, reinicio)</code></pre>
                        </div>
                    </article>

                    <!-- Sintaxis B√°sica -->
                    <article class="topic">
                        <h3 class="topic-title">Sintaxis de Transacciones</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Comandos Principales</span>
                            </div>
                            <pre><code class="language-sql">-- START TRANSACTION (o BEGIN): Inicia una transacci√≥n
    START TRANSACTION;

    -- ... ejecutar m√∫ltiples comandos SQL ...

    -- COMMIT: Confirma y guarda TODOS los cambios
    COMMIT;

    -- ROLLBACK: Revierte TODOS los cambios (deshace la transacci√≥n)
    ROLLBACK;

    -- AUTOCOMMIT (por defecto en MySQL)
    -- Cada comando SQL se ejecuta autom√°ticamente en su propia transacci√≥n
    -- Para transacciones manuales, debes usar START TRANSACTION</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 1: Transferencia Bancaria</span>
                            </div>
                            <pre><code class="language-sql">-- Crear tabla de cuentas bancarias
    CREATE TABLE cuentas (
        id_cuenta INT PRIMARY KEY AUTO_INCREMENT,
        titular VARCHAR(100),
        saldo DECIMAL(10,2) CHECK (saldo >= 0)  -- No permitir saldo negativo
    );

    INSERT INTO cuentas (titular, saldo) VALUES
        ('Ana Garc√≠a', 1000.00),
        ('Carlos L√≥pez', 500.00);

    -- Verificar saldos iniciales
    SELECT * FROM cuentas;
    -- +----------+--------------+---------+
    -- | id_cuenta| titular      | saldo   |
    -- +----------+--------------+---------+
    -- | 1        | Ana Garc√≠a   | 1000.00 |
    -- | 2        | Carlos L√≥pez | 500.00  |
    -- +----------+--------------+---------+

    -- TRANSACCI√ìN: Transferir 200‚Ç¨ de Ana (id=1) a Carlos (id=2)
    START TRANSACTION;

    -- Paso 1: Restar de cuenta de Ana
    UPDATE cuentas
    SET saldo = saldo - 200
    WHERE id_cuenta = 1;

    -- Paso 2: Sumar a cuenta de Carlos
    UPDATE cuentas
    SET saldo = saldo + 200
    WHERE id_cuenta = 2;

    -- Si TODO sali√≥ bien, confirmar:
    COMMIT;

    -- Verificar resultado
    SELECT * FROM cuentas;
    -- +----------+--------------+---------+
    -- | id_cuenta| titular      | saldo   |
    -- +----------+--------------+---------+
    -- | 1        | Ana Garc√≠a   | 800.00  |  ‚Üê Rest√≥ 200
    -- | 2        | Carlos L√≥pez | 700.00  |  ‚Üê Sum√≥ 200
    -- +----------+--------------+---------+

    -- ‚úÖ Transferencia completada con √©xito</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 2: Transacci√≥n con ROLLBACK (Error)</span>
                            </div>
                            <pre><code class="language-sql">-- Intentar transferir 2000‚Ç¨ de Ana (solo tiene 800‚Ç¨)
    START TRANSACTION;

    -- Paso 1: Restar de cuenta de Ana
    UPDATE cuentas
    SET saldo = saldo - 2000
    WHERE id_cuenta = 1;
    -- ‚ùå ERROR: Check constraint failed (saldo no puede ser negativo)

    -- Como hubo error, REVERTIR transacci√≥n:
    ROLLBACK;

    -- Verificar que NO cambi√≥ nada
    SELECT * FROM cuentas;
    -- +----------+--------------+---------+
    -- | id_cuenta| titular      | saldo   |
    -- +----------+--------------+---------+
    -- | 1        | Ana Garc√≠a   | 800.00  |  ‚Üê Sigue igual (ROLLBACK funcion√≥)
    -- | 2        | Carlos L√≥pez | 700.00  |
    -- +----------+--------------+---------+

    -- ‚úÖ Los datos permanecen consistentes</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 3: ROLLBACK Manual (Decisi√≥n de Usuario)</span>
                            </div>
                            <pre><code class="language-sql">-- Imagina una aplicaci√≥n donde el usuario puede CANCELAR una operaci√≥n

    START TRANSACTION;

    -- Usuario a√±ade productos al carrito (temporal)
    INSERT INTO carrito_temporal (id_usuario, id_producto, cantidad) VALUES
        (1, 101, 2),
        (1, 102, 1);

    -- Usuario revisa...
    SELECT * FROM carrito_temporal WHERE id_usuario = 1;

    -- Usuario decide CANCELAR (no comprar)
    -- Revertimos inserciones:
    ROLLBACK;

    -- Carrito queda vac√≠o
    SELECT * FROM carrito_temporal WHERE id_usuario = 1;
    -- (0 filas) ‚úÖ</code></pre>
                        </div>
                    </article>

                    <!-- Transacciones Complejas -->
                    <article class="topic">
                        <h3 class="topic-title">Transacciones con M√∫ltiples Operaciones</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 4: Procesar un Pedido Completo</span>
                            </div>
                            <pre><code class="language-sql">-- Tablas necesarias
    CREATE TABLE productos (
        id_producto INT PRIMARY KEY,
        nombre VARCHAR(100),
        stock INT,
        precio DECIMAL(10,2)
    );

    CREATE TABLE pedidos (
        id_pedido INT PRIMARY KEY AUTO_INCREMENT,
        id_cliente INT,
        fecha_pedido DATETIME DEFAULT CURRENT_TIMESTAMP,
        total DECIMAL(10,2)
    );

    CREATE TABLE detalle_pedidos (
        id_detalle INT PRIMARY KEY AUTO_INCREMENT,
        id_pedido INT,
        id_producto INT,
        cantidad INT,
        precio_unitario DECIMAL(10,2),
        FOREIGN KEY (id_pedido) REFERENCES pedidos(id_pedido),
        FOREIGN KEY (id_producto) REFERENCES productos(id_producto)
    );

    -- Datos iniciales
    INSERT INTO productos (id_producto, nombre, stock, precio) VALUES
        (1, 'Laptop', 10, 699.00),
        (2, 'Mouse', 50, 25.50);

    -- TRANSACCI√ìN: Procesar pedido de cliente 123
    -- Compra: 2 laptops + 3 ratones
    START TRANSACTION;

    -- 1. Crear pedido principal (total se calcula despu√©s)
    INSERT INTO pedidos (id_cliente, total) VALUES (123, 0);
    SET @id_pedido = LAST_INSERT_ID();  -- Guardar ID generado

    -- 2. Verificar stock ANTES de vender
    SELECT stock FROM productos WHERE id_producto = 1;  -- Laptop: 10 en stock ‚úÖ
    SELECT stock FROM productos WHERE id_producto = 2;  -- Mouse: 50 en stock ‚úÖ

    -- 3. Reducir stock
    UPDATE productos SET stock = stock - 2 WHERE id_producto = 1;  -- Laptop
    UPDATE productos SET stock = stock - 3 WHERE id_producto = 2;  -- Mouse

    -- 4. A√±adir detalles del pedido
    INSERT INTO detalle_pedidos (id_pedido, id_producto, cantidad, precio_unitario)
    VALUES
        (@id_pedido, 1, 2, 699.00),   -- 2 laptops
        (@id_pedido, 2, 3, 25.50);    -- 3 ratones

    -- 5. Calcular y actualizar total del pedido
    UPDATE pedidos
    SET total = (
        SELECT SUM(cantidad * precio_unitario)
        FROM detalle_pedidos
        WHERE id_pedido = @id_pedido
    )
    WHERE id_pedido = @id_pedido;

    -- 6. Verificar que todo es correcto
    SELECT * FROM pedidos WHERE id_pedido = @id_pedido;
    SELECT * FROM detalle_pedidos WHERE id_pedido = @id_pedido;
    SELECT id_producto, stock FROM productos WHERE id_producto IN (1, 2);

    -- Si TODO est√° bien:
    COMMIT;

    -- Resultado final:
    -- pedidos: id_pedido=1, total=1474.50 (2*699 + 3*25.50)
    -- productos: Laptop stock=8, Mouse stock=47
    -- ‚úÖ Pedido procesado correctamente</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 5: Error en Transacci√≥n Compleja</span>
                            </div>
                            <pre><code class="language-sql">-- Intentar vender 20 laptops (solo hay 8 en stock tras pedido anterior)

    START TRANSACTION;

    INSERT INTO pedidos (id_cliente, total) VALUES (456, 0);
    SET @id_pedido = LAST_INSERT_ID();

    -- Intentar reducir stock
    UPDATE productos SET stock = stock - 20 WHERE id_producto = 1;
    -- ‚ùå Si hay constraint CHECK (stock >= 0), falla aqu√≠
    -- O si la aplicaci√≥n verifica manualmente:

    -- Verificaci√≥n manual en aplicaci√≥n:
    SELECT stock FROM productos WHERE id_producto = 1;  -- stock=8
    -- Aplicaci√≥n detecta: 8 < 20 ‚Üí STOCK INSUFICIENTE

    -- REVERTIR toda la transacci√≥n
    ROLLBACK;

    -- Verificar que el pedido NO se cre√≥
    SELECT * FROM pedidos WHERE id_pedido = @id_pedido;
    -- (0 filas) ‚úÖ

    -- Stock sigue igual
    SELECT stock FROM productos WHERE id_producto = 1;
    -- stock = 8 ‚úÖ (no cambi√≥)</code></pre>
                        </div>
                    </article>

                    <!-- SAVEPOINT -->
                    <article class="topic">
                        <h3 class="topic-title">SAVEPOINT - Puntos de Guardado</h3>
                        <p class="topic-description">
                            <strong>SAVEPOINT</strong> permite crear puntos intermedios dentro de una transacci√≥n.
                            Puedes revertir a un savepoint sin cancelar TODA la transacci√≥n.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 6: Usar SAVEPOINT</span>
                            </div>
                            <pre><code class="language-sql">START TRANSACTION;

    -- Operaci√≥n 1: Insertar cliente
    INSERT INTO clientes (nombre, email) VALUES ('Pedro Ruiz', 'pedro@email.com');
    SAVEPOINT after_cliente;  -- Punto de guardado 1

    -- Operaci√≥n 2: Insertar direcci√≥n del cliente
    INSERT INTO direcciones (id_cliente, calle, ciudad) VALUES (LAST_INSERT_ID(), 'Calle Mayor 10', 'Madrid');
    SAVEPOINT after_direccion;  -- Punto de guardado 2

    -- Operaci√≥n 3: Intentar insertar tel√©fono duplicado
    INSERT INTO telefonos (id_cliente, numero) VALUES (LAST_INSERT_ID(), '666111222');
    -- ‚ùå ERROR: N√∫mero duplicado (ya existe)

    -- Revertir SOLO la √∫ltima operaci√≥n (desde after_direccion)
    ROLLBACK TO SAVEPOINT after_direccion;

    -- Cliente y direcci√≥n siguen en la transacci√≥n, solo se revirti√≥ el tel√©fono

    -- Operaci√≥n 4: Insertar tel√©fono correcto
    INSERT INTO telefonos (id_cliente, numero) VALUES (LAST_INSERT_ID(), '666999888');

    -- Confirmar TODO
    COMMIT;

    -- Resultado:
    -- ‚úÖ Cliente insertado
    -- ‚úÖ Direcci√≥n insertada
    -- ‚úÖ Tel√©fono correcto insertado
    -- ‚ùå Tel√©fono duplicado NO insertado (revertido con SAVEPOINT)</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Sintaxis de SAVEPOINT</span>
                            </div>
                            <pre><code class="language-sql">START TRANSACTION;

    -- Operaciones...
    SAVEPOINT nombre_savepoint;

    -- M√°s operaciones...

    -- Si hay error, volver al savepoint:
    ROLLBACK TO SAVEPOINT nombre_savepoint;

    -- O liberar el savepoint (ya no necesario):
    RELEASE SAVEPOINT nombre_savepoint;

    -- Finalmente:
    COMMIT;  -- o ROLLBACK; para cancelar todo</code></pre>
                        </div>
                    </article>

                    <!-- Niveles de Aislamiento -->
                    <article class="topic">
                        <h3 class="topic-title">Niveles de Aislamiento (Isolation Levels)</h3>
                        <p class="topic-description">
                            Los <strong>niveles de aislamiento</strong> controlan qu√© tan "aisladas" est√°n las transacciones concurrentes.
                            Mayor aislamiento = m√°s seguridad, pero menos concurrencia (m√°s lento).
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Niveles de Aislamiento en MySQL</span>
                            </div>
                            <pre><code class="language-sql">-- 4 niveles est√°ndar (de menos a m√°s aislamiento):

    -- 1. READ UNCOMMITTED (lectura sucia)
    -- Puede leer cambios NO confirmados de otras transacciones
    -- Problema: "Dirty read" (leer datos que pueden revertirse)
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

    -- 2. READ COMMITTED (lectura confirmada) - M√°s com√∫n en producci√≥n
    -- Solo lee cambios confirmados (despu√©s de COMMIT)
    -- Problema: "Non-repeatable read" (misma query da resultados diferentes en la misma transacci√≥n)
    SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

    -- 3. REPEATABLE READ (lectura repetible) - DEFAULT en MySQL
    -- Misma query en la transacci√≥n da siempre el mismo resultado
    -- Problema: "Phantom read" (nuevas filas insertadas por otras transacciones pueden aparecer)
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

    -- 4. SERIALIZABLE (serializable) - M√°ximo aislamiento
    -- Transacciones se ejecutan completamente aisladas (como si fueran secuenciales)
    -- Sin problemas de concurrencia, pero MUY LENTO
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

    -- Ver nivel actual
    SELECT @@transaction_isolation;

    -- Cambiar nivel globalmente (para todas las conexiones nuevas)
    SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Ejemplo 7: Problema de Dirty Read</span>
                            </div>
                            <pre><code class="language-sql">-- Configuraci√≥n: READ UNCOMMITTED

    -- TRANSACCI√ìN A (ventana 1):
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    START TRANSACTION;
    UPDATE cuentas SET saldo = saldo + 1000 WHERE id_cuenta = 1;
    -- NO hace COMMIT a√∫n

    -- TRANSACCI√ìN B (ventana 2, simult√°nea):
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    START TRANSACTION;
    SELECT saldo FROM cuentas WHERE id_cuenta = 1;
    -- ‚ùå Lee el saldo CON los +1000 (aunque NO est√°n confirmados)
    -- Si Transacci√≥n A hace ROLLBACK, este dato era FALSO

    -- Soluci√≥n: Usar READ COMMITTED o superior</code></pre>
                        </div>
                    </article>

                    <!-- Buenas Pr√°cticas -->
                    <article class="topic">
                        <h3 class="topic-title">Buenas Pr√°cticas con Transacciones</h3>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">C√≥digo de Ejemplo con Manejo de Errores</span>
                            </div>
                            <pre><code class="language-sql">-- Pseudoc√≥digo (l√≥gica en aplicaci√≥n, no SQL puro)

    START TRANSACTION;

    TRY {
        -- 1. Validar datos
        IF (saldo_origen < monto_transferencia) {
            THROW 'Saldo insuficiente';
        }

        -- 2. Ejecutar operaciones
        UPDATE cuentas SET saldo = saldo - monto WHERE id_cuenta = origen;
        UPDATE cuentas SET saldo = saldo + monto WHERE id_cuenta = destino;

        -- 3. Registrar log
        INSERT INTO log_transferencias (...) VALUES (...);

        -- 4. Si todo OK, confirmar
        COMMIT;

    } CATCH (error) {
        -- Si hubo cualquier error, revertir
        ROLLBACK;

        -- Registrar error para an√°lisis
        INSERT INTO log_errores (mensaje, fecha) VALUES (error, NOW());

        -- Informar al usuario
        THROW error;
    }</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Reglas de Oro</span>
                            </div>
                            <pre><code class="language-sql">-- ‚úÖ HACER:
    -- 1. Mant√©n transacciones CORTAS
    --    Menos tiempo abierta = menos bloqueos = mejor concurrencia
    START TRANSACTION;
    -- Solo operaciones esenciales
    COMMIT;

    -- 2. Usa el nivel de aislamiento M√çNIMO necesario
    --    READ COMMITTED suele ser suficiente

    -- 3. Siempre maneja errores
    --    Todo c√≥digo entre START TRANSACTION y COMMIT debe tener try-catch

    -- 4. Usa ROLLBACK si detectas problemas
    IF (condicion_error) THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Error descriptivo';
    END IF;

    -- ‚ùå EVITAR:
    -- 1. NO incluyas l√≥gica de aplicaci√≥n compleja dentro de transacciones
    --    Ejemplo: llamadas HTTP, procesamiento de archivos, sleep()
    --    Solo operaciones de BD esenciales

    -- 2. NO dejes transacciones abiertas indefinidamente
    --    Si el usuario tarda en decidir, COMMIT/ROLLBACK antes

    -- 3. NO uses SERIALIZABLE sin raz√≥n
    --    Solo para casos muy espec√≠ficos (contabilidad cr√≠tica)</code></pre>
                        </div>
                    </article>

                    <!-- Errores Comunes -->
                    <div class="error-box">
                        <div class="error-title">‚ö†Ô∏è Errores Comunes con Transacciones</div>
                        <ul class="error-list">
                            <li><strong>Olvidar COMMIT:</strong> Cambios quedan en memoria, no se guardan. Siempre termina con COMMIT o ROLLBACK.</li>
                            <li><strong>Transacciones demasiado largas:</strong> Bloquean tablas, causan timeouts. Mant√©n transacciones cortas.</li>
                            <li><strong>No manejar errores:</strong> Si un UPDATE falla a mitad de transacci√≥n, DEBES hacer ROLLBACK expl√≠citamente.</li>
                            <li><strong>DDL dentro de transacciones:</strong> <code>CREATE TABLE</code>, <code>ALTER TABLE</code> hacen COMMIT impl√≠cito (terminan la transacci√≥n).</li>
                            <li><strong>Asumir que AUTOCOMMIT est√° off:</strong> En MySQL AUTOCOMMIT=1 por defecto. Usa START TRANSACTION expl√≠citamente.</li>
                            <li><strong>Leer datos sin transacci√≥n:</strong> En aplicaciones concurrentes, dos SELECTs consecutivos pueden dar resultados diferentes.</li>
                        </ul>
                    </div>

                    <!-- Pro Tips -->
                    <div class="tip-box">
                        <div class="tip-title">üí° Pro Tips - Transacciones</div>
                        <ul class="tip-list">
                            <li><strong>InnoDB</strong> soporta transacciones. <strong>MyISAM</strong> NO (engine antiguo de MySQL). Usa InnoDB siempre.</li>
                            <li>En aplicaciones web, NUNCA dejes transacciones abiertas entre requests HTTP.</li>
                            <li>Para operaciones masivas (ej: importar 1M de filas), considera hacer <strong>COMMIT cada N filas</strong> (ej: cada 1000).</li>
                            <li><strong>FOR UPDATE</strong>: Bloquea filas en SELECT para prevenir modificaciones concurrentes:
                                <code>SELECT * FROM cuentas WHERE id = 1 FOR UPDATE;</code></li>
                            <li>Usa <strong>procedimientos almacenados</strong> para l√≥gica compleja de transacciones (menos latencia red).</li>
                            <li><strong>SHOW ENGINE INNODB STATUS;</strong> muestra transacciones activas y deadlocks.</li>
                            <li>MySQL detecta y resuelve <strong>deadlocks</strong> autom√°ticamente (revierte una transacci√≥n). Tu app debe reintentar.</li>
                            <li><strong>REPEATABLE READ</strong> (default MySQL) usa snapshots: ves datos del momento START TRANSACTION.</li>
                            <li>En producci√≥n, monitorea transacciones largas con <code>SHOW PROCESSLIST;</code></li>
                        </ul>
                    </div>
                </section>

                <!-- EJERCICIOS RESUELTOS -->
                <section id="ejercicios" class="content-section">
                    <h2 class="section-title">Ejercicios Resueltos</h2>
                    <p class="topic-description">
                        Esta secci√≥n contiene ejercicios pr√°cticos que cubren todos los conceptos vistos.
                        Cada ejercicio incluye el enunciado, la soluci√≥n paso a paso y explicaciones.
                    </p>

                    <!-- Ejercicio 1 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 1: Crear Base de Datos de Biblioteca</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Crea una base de datos para una biblioteca que gestione libros, autores y pr√©stamos.
                            Cada libro tiene t√≠tulo, ISBN, a√±o de publicaci√≥n y un autor. Cada pr√©stamo registra qu√© libro se prest√≥,
                            a qu√© socio, y las fechas de pr√©stamo y devoluci√≥n.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n - Paso 1: Dise√±o de Tablas</span>
                            </div>
                            <pre><code class="language-sql">-- Crear base de datos
    CREATE DATABASE biblioteca;
    USE biblioteca;

    -- Tabla autores
    CREATE TABLE autores (
        id_autor INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100) NOT NULL,
        nacionalidad VARCHAR(50),
        fecha_nacimiento DATE
    );

    -- Tabla libros
    CREATE TABLE libros (
        id_libro INT PRIMARY KEY AUTO_INCREMENT,
        titulo VARCHAR(200) NOT NULL,
        isbn VARCHAR(20) UNIQUE NOT NULL,
        a√±o_publicacion INT,
        id_autor INT,
        disponible BOOLEAN DEFAULT TRUE,
        FOREIGN KEY (id_autor) REFERENCES autores(id_autor)
    );

    -- Tabla socios
    CREATE TABLE socios (
        id_socio INT PRIMARY KEY AUTO_INCREMENT,
        nombre VARCHAR(100) NOT NULL,
        email VARCHAR(100) UNIQUE,
        telefono VARCHAR(15),
        fecha_registro DATE DEFAULT (CURRENT_DATE)
    );

    -- Tabla pr√©stamos
    CREATE TABLE prestamos (
        id_prestamo INT PRIMARY KEY AUTO_INCREMENT,
        id_libro INT NOT NULL,
        id_socio INT NOT NULL,
        fecha_prestamo DATE NOT NULL,
        fecha_devolucion_prevista DATE NOT NULL,
        fecha_devolucion_real DATE,
        FOREIGN KEY (id_libro) REFERENCES libros(id_libro),
        FOREIGN KEY (id_socio) REFERENCES socios(id_socio)
    );</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n - Paso 2: Insertar Datos</span>
                            </div>
                            <pre><code class="language-sql">-- Insertar autores
    INSERT INTO autores (nombre, nacionalidad, fecha_nacimiento) VALUES
        ('Gabriel Garc√≠a M√°rquez', 'Colombiana', '1927-03-06'),
        ('Isabel Allende', 'Chilena', '1942-08-02'),
        ('Mario Vargas Llosa', 'Peruana', '1936-03-28');

    -- Insertar libros
    INSERT INTO libros (titulo, isbn, a√±o_publicacion, id_autor, disponible) VALUES
        ('Cien a√±os de soledad', '978-0307474728', 1967, 1, TRUE),
        ('El amor en los tiempos del c√≥lera', '978-0307389732', 1985, 1, TRUE),
        ('La casa de los esp√≠ritus', '978-1501117015', 1982, 2, FALSE),  -- Prestado
        ('La ciudad y los perros', '978-8420471839', 1963, 3, TRUE);

    -- Insertar socios
    INSERT INTO socios (nombre, email, telefono) VALUES
        ('Ana Mart√≠nez', 'ana.martinez@email.com', '666111222'),
        ('Carlos Ruiz', 'carlos.ruiz@email.com', '666333444'),
        ('Laura G√≥mez', 'laura.gomez@email.com', '666555666');

    -- Insertar pr√©stamos
    INSERT INTO prestamos (id_libro, id_socio, fecha_prestamo, fecha_devolucion_prevista) VALUES
        (3, 1, '2024-11-01', '2024-11-15');  -- La casa de los esp√≠ritus prestado a Ana

    -- Actualizar disponibilidad del libro prestado
    UPDATE libros SET disponible = FALSE WHERE id_libro = 3;</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 2 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 2: Consultas B√°sicas con WHERE y ORDER BY</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Usando la base de datos de biblioteca:
                            1. Lista todos los libros disponibles.
                            2. Encuentra libros publicados despu√©s de 1980.
                            3. Muestra los 3 socios m√°s recientes.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- 1. Libros disponibles
    SELECT titulo, isbn, a√±o_publicacion
    FROM libros
    WHERE disponible = TRUE;

    -- Resultado:
    -- +----------------------------------+----------------+------------------+
    -- | titulo                           | isbn           | a√±o_publicacion  |
    -- +----------------------------------+----------------+------------------+
    -- | Cien a√±os de soledad             | 978-0307474728 | 1967             |
    -- | El amor en los tiempos del c√≥lera| 978-0307389732 | 1985             |
    -- | La ciudad y los perros           | 978-8420471839 | 1963             |
    -- +----------------------------------+----------------+------------------+

    -- 2. Libros publicados despu√©s de 1980
    SELECT titulo, a√±o_publicacion, disponible
    FROM libros
    WHERE a√±o_publicacion > 1980
    ORDER BY a√±o_publicacion ASC;

    -- Resultado:
    -- +----------------------------------+------------------+-----------+
    -- | titulo                           | a√±o_publicacion  | disponible|
    -- +----------------------------------+------------------+-----------+
    -- | La casa de los esp√≠ritus         | 1982             | FALSE     |
    -- | El amor en los tiempos del c√≥lera| 1985             | TRUE      |
    -- +----------------------------------+------------------+-----------+

    -- 3. Los 3 socios m√°s recientes
    SELECT nombre, email, fecha_registro
    FROM socios
    ORDER BY fecha_registro DESC
    LIMIT 3;

    -- Resultado (asumiendo fecha_registro con valores):
    -- +--------------+-------------------------+----------------+
    -- | nombre       | email                   | fecha_registro |
    -- +--------------+-------------------------+----------------+
    -- | Laura G√≥mez  | laura.gomez@email.com   | 2024-11-18     |
    -- | Carlos Ruiz  | carlos.ruiz@email.com   | 2024-11-10     |
    -- | Ana Mart√≠nez | ana.martinez@email.com  | 2024-11-01     |
    -- +--------------+-------------------------+----------------+</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 3 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 3: JOIN - Libros con sus Autores</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Muestra todos los libros con el nombre de su autor y su nacionalidad.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">SELECT
        l.titulo,
        l.isbn,
        l.a√±o_publicacion,
        a.nombre AS autor,
        a.nacionalidad
    FROM libros l
    INNER JOIN autores a ON l.id_autor = a.id_autor
    ORDER BY l.a√±o_publicacion;

    -- Resultado:
    -- +----------------------------------+----------------+------------------+------------------------+--------------+
    -- | titulo                           | isbn           | a√±o_publicacion  | autor                  | nacionalidad |
    -- +----------------------------------+----------------+------------------+------------------------+--------------+
    -- | La ciudad y los perros           | 978-8420471839 | 1963             | Mario Vargas Llosa     | Peruana      |
    -- | Cien a√±os de soledad             | 978-0307474728 | 1967             | Gabriel Garc√≠a M√°rquez | Colombiana   |
    -- | La casa de los esp√≠ritus         | 978-1501117015 | 1982             | Isabel Allende         | Chilena      |
    -- | El amor en los tiempos del c√≥lera| 978-0307389732 | 1985             | Gabriel Garc√≠a M√°rquez | Colombiana   |
    -- +----------------------------------+----------------+------------------+------------------------+--------------+</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 4 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 4: LEFT JOIN - Socios con/sin Pr√©stamos</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Lista TODOS los socios y muestra cu√°ntos pr√©stamos activos tienen.
                            Incluye socios que no han hecho pr√©stamos.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">SELECT
        s.nombre,
        s.email,
        COUNT(p.id_prestamo) AS prestamos_activos
    FROM socios s
    LEFT JOIN prestamos p ON s.id_socio = p.id_socio
        AND p.fecha_devolucion_real IS NULL  -- Solo pr√©stamos NO devueltos
    GROUP BY s.id_socio, s.nombre, s.email
    ORDER BY prestamos_activos DESC;

    -- Resultado:
    -- +--------------+-------------------------+-------------------+
    -- | nombre       | email                   | prestamos_activos |
    -- +--------------+-------------------------+-------------------+
    -- | Ana Mart√≠nez | ana.martinez@email.com  | 1                 |  ‚Üê Tiene 1 pr√©stamo activo
    -- | Carlos Ruiz  | carlos.ruiz@email.com   | 0                 |  ‚Üê Sin pr√©stamos
    -- | Laura G√≥mez  | laura.gomez@email.com   | 0                 |  ‚Üê Sin pr√©stamos
    -- +--------------+-------------------------+-------------------+

    -- Explicaci√≥n:
    -- - LEFT JOIN garantiza que TODOS los socios aparezcan
    -- - COUNT(p.id_prestamo) cuenta solo si hay pr√©stamo (0 si NULL)
    -- - WHERE en el JOIN filtra solo pr√©stamos sin devolver</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 5 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 5: GROUP BY - Libros por Autor</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Muestra cu√°ntos libros ha escrito cada autor y el a√±o del libro m√°s reciente de cada uno.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">SELECT
        a.nombre AS autor,
        a.nacionalidad,
        COUNT(l.id_libro) AS total_libros,
        MAX(l.a√±o_publicacion) AS libro_mas_reciente
    FROM autores a
    LEFT JOIN libros l ON a.id_autor = l.id_autor
    GROUP BY a.id_autor, a.nombre, a.nacionalidad
    HAVING COUNT(l.id_libro) > 0  -- Solo autores con al menos 1 libro
    ORDER BY total_libros DESC;

    -- Resultado:
    -- +------------------------+--------------+--------------+--------------------+
    -- | autor                  | nacionalidad | total_libros | libro_mas_reciente |
    -- +------------------------+--------------+--------------+--------------------+
    -- | Gabriel Garc√≠a M√°rquez | Colombiana   | 2            | 1985               |
    -- | Isabel Allende         | Chilena      | 1            | 1982               |
    -- | Mario Vargas Llosa     | Peruana      | 1            | 1963               |
    -- +------------------------+--------------+--------------+--------------------+

    -- Explicaci√≥n:
    -- - COUNT cuenta libros por autor
    -- - MAX encuentra el a√±o m√°s reciente
    -- - HAVING filtra autores sin libros en el sistema</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 6 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 6: Subconsulta - Libros M√°s Antiguos que el Promedio</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Encuentra libros publicados antes del a√±o promedio de publicaci√≥n.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- Primero, calcular el promedio
    SELECT AVG(a√±o_publicacion) AS a√±o_promedio FROM libros;
    -- Resultado: 1974.25 (promedio de 1967, 1985, 1982, 1963)

    -- Consulta con subconsulta
    SELECT
        titulo,
        a√±o_publicacion,
        (SELECT AVG(a√±o_publicacion) FROM libros) AS a√±o_promedio
    FROM libros
    WHERE a√±o_publicacion < (SELECT AVG(a√±o_publicacion) FROM libros)
    ORDER BY a√±o_publicacion;

    -- Resultado:
    -- +----------------------+------------------+--------------+
    -- | titulo               | a√±o_publicacion  | a√±o_promedio |
    -- +----------------------+------------------+--------------+
    -- | La ciudad y los perros| 1963            | 1974.25      |
    -- | Cien a√±os de soledad  | 1967            | 1974.25      |
    -- +----------------------+------------------+--------------+

    -- Explicaci√≥n:
    -- - Subconsulta calcula AVG(a√±o_publicacion)
    -- - WHERE compara cada libro con ese promedio
    -- - Solo se muestran libros con a√±o < promedio</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 7 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 7: UPDATE con JOIN - Devolver Libro</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Registra la devoluci√≥n del libro "La casa de los esp√≠ritus" el d√≠a de hoy
                            y actualiza su disponibilidad.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- Paso 1: Actualizar fecha de devoluci√≥n en pr√©stamos
    UPDATE prestamos
    SET fecha_devolucion_real = CURDATE()
    WHERE id_libro = (SELECT id_libro FROM libros WHERE titulo = 'La casa de los esp√≠ritus')
    AND fecha_devolucion_real IS NULL;  -- Solo pr√©stamos sin devolver

    -- Paso 2: Marcar libro como disponible
    UPDATE libros
    SET disponible = TRUE
    WHERE titulo = 'La casa de los esp√≠ritus';

    -- Verificar
    SELECT
        l.titulo,
        l.disponible,
        p.fecha_prestamo,
        p.fecha_devolucion_real
    FROM libros l
    LEFT JOIN prestamos p ON l.id_libro = p.id_libro
    WHERE l.titulo = 'La casa de los esp√≠ritus';

    -- Resultado:
    -- +--------------------------+-----------+----------------+-----------------------+
    -- | titulo                   | disponible| fecha_prestamo | fecha_devolucion_real |
    -- +--------------------------+-----------+----------------+-----------------------+
    -- | La casa de los esp√≠ritus | TRUE      | 2024-11-01     | 2024-11-18            |
    -- +--------------------------+-----------+----------------+-----------------------+</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 8 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 8: Transacci√≥n - Registrar Nuevo Pr√©stamo</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Registra un nuevo pr√©stamo del libro "Cien a√±os de soledad" a Carlos Ruiz.
                            Usa una transacci√≥n para garantizar que: 1) el libro est√© disponible, 2) se registre el pr√©stamo,
                            3) se marque el libro como no disponible.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">START TRANSACTION;

    -- Paso 1: Verificar que el libro est√© disponible
    SELECT disponible FROM libros WHERE titulo = 'Cien a√±os de soledad';
    -- Si devuelve FALSE, hacer ROLLBACK

    -- Asumiendo que est√° disponible (TRUE), continuar:

    -- Paso 2: Registrar pr√©stamo (14 d√≠as de plazo)
    INSERT INTO prestamos (id_libro, id_socio, fecha_prestamo, fecha_devolucion_prevista)
    VALUES (
        (SELECT id_libro FROM libros WHERE titulo = 'Cien a√±os de soledad'),
        (SELECT id_socio FROM socios WHERE nombre = 'Carlos Ruiz'),
        CURDATE(),
        DATE_ADD(CURDATE(), INTERVAL 14 DAY)
    );

    -- Paso 3: Marcar libro como no disponible
    UPDATE libros
    SET disponible = FALSE
    WHERE titulo = 'Cien a√±os de soledad';

    -- Paso 4: Verificar todo est√° correcto
    SELECT
        l.titulo,
        l.disponible,
        s.nombre AS socio,
        p.fecha_prestamo,
        p.fecha_devolucion_prevista
    FROM prestamos p
    INNER JOIN libros l ON p.id_libro = l.id_libro
    INNER JOIN socios s ON p.id_socio = s.id_socio
    WHERE p.id_prestamo = LAST_INSERT_ID();

    -- Si todo OK:
    COMMIT;

    -- Si hay error (ej: libro no disponible):
    -- ROLLBACK;</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 9 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 9: Normalizaci√≥n - Corregir Tabla Desnormalizada</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Tienes esta tabla mal dise√±ada. Normal√≠zala a 3FN.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Tabla Original (Desnormalizada)</span>
                            </div>
                            <pre><code class="language-sql">-- Tabla con problemas
    CREATE TABLE prestamos_mal (
        id_prestamo INT,
        titulo_libro VARCHAR(200),
        autor_libro VARCHAR(100),           -- ‚ùå Depende de titulo (transitiva)
        isbn VARCHAR(20),                   -- ‚ùå Depende de titulo
        nombre_socio VARCHAR(100),
        email_socio VARCHAR(100),           -- ‚ùå Depende de nombre_socio (transitiva)
        telefono_socio VARCHAR(15),         -- ‚ùå Depende de nombre_socio
        fecha_prestamo DATE
    );

    -- Problemas:
    -- - Viola 3FN: autor, ISBN dependen de t√≠tulo (no de id_prestamo directamente)
    -- - Viola 3FN: email, tel√©fono dependen de nombre_socio
    -- - REDUNDANCIA: Si mismo libro se presta 10 veces, datos de autor/ISBN se repiten 10 veces</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n Normalizada a 3FN</span>
                            </div>
                            <pre><code class="language-sql">-- Ya tenemos las tablas normalizadas de ejercicios anteriores:

    -- libros (id_libro, titulo, isbn, id_autor) ‚úÖ
    -- autores (id_autor, nombre) ‚úÖ
    -- socios (id_socio, nombre, email, telefono) ‚úÖ
    -- prestamos (id_prestamo, id_libro, id_socio, fecha_prestamo) ‚úÖ

    -- Migrar datos de prestamos_mal a estructura normalizada:

    -- 1. Insertar autores √∫nicos
    INSERT INTO autores (nombre)
    SELECT DISTINCT autor_libro FROM prestamos_mal
    WHERE autor_libro NOT IN (SELECT nombre FROM autores);

    -- 2. Insertar libros √∫nicos
    INSERT INTO libros (titulo, isbn, id_autor)
    SELECT DISTINCT
        p.titulo_libro,
        p.isbn,
        a.id_autor
    FROM prestamos_mal p
    INNER JOIN autores a ON p.autor_libro = a.nombre
    WHERE p.isbn NOT IN (SELECT isbn FROM libros);

    -- 3. Insertar socios √∫nicos
    INSERT INTO socios (nombre, email, telefono)
    SELECT DISTINCT nombre_socio, email_socio, telefono_socio
    FROM prestamos_mal
    WHERE email_socio NOT IN (SELECT email FROM socios);

    -- 4. Insertar pr√©stamos normalizados
    INSERT INTO prestamos (id_libro, id_socio, fecha_prestamo)
    SELECT
        l.id_libro,
        s.id_socio,
        pm.fecha_prestamo
    FROM prestamos_mal pm
    INNER JOIN libros l ON pm.isbn = l.isbn
    INNER JOIN socios s ON pm.email_socio = s.email;

    -- Ahora DROP TABLE prestamos_mal;

    -- ‚úÖ Beneficios:
    -- - Datos de libros almacenados UNA vez
    -- - Cambiar email de socio: solo 1 UPDATE
    -- - Sin redundancia</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 10 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 10: Crear √çndice para Optimizar B√∫squedas</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> La biblioteca busca frecuentemente libros por ISBN y por t√≠tulo.
                            Crea √≠ndices apropiados y usa EXPLAIN para verificar su uso.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- SIN √≠ndices (excepto PK y UNIQUE que ya existen)
    EXPLAIN SELECT * FROM libros WHERE titulo = 'Cien a√±os de soledad';
    -- type: ALL (full table scan) ‚ùå

    -- Crear √≠ndice en titulo (b√∫squedas frecuentes)
    CREATE INDEX idx_titulo ON libros(titulo);

    -- Ahora EXPLAIN muestra:
    EXPLAIN SELECT * FROM libros WHERE titulo = 'Cien a√±os de soledad';
    -- type: ref ‚úÖ (usa √≠ndice)
    -- key: idx_titulo ‚úÖ
    -- rows: 1 ‚úÖ (examina solo 1 fila en vez de todas)

    -- ISBN ya tiene √≠ndice autom√°tico (es UNIQUE)
    EXPLAIN SELECT * FROM libros WHERE isbn = '978-0307474728';
    -- type: const ‚úÖ (b√∫squeda por UNIQUE, m√°s r√°pido)
    -- key: isbn ‚úÖ

    -- √çndice compuesto para b√∫squeda por autor + a√±o
    CREATE INDEX idx_autor_a√±o ON libros(id_autor, a√±o_publicacion);

    -- Optimiza esta query:
    EXPLAIN SELECT * FROM libros
    WHERE id_autor = 1 AND a√±o_publicacion > 1980;
    -- type: range ‚úÖ
    -- key: idx_autor_a√±o ‚úÖ

    -- Verificar √≠ndices creados
    SHOW INDEX FROM libros;

    -- Resultado:
    -- +--------+------------+----------------+--------------+------------------+
    -- | Table  | Non_unique | Key_name       | Seq_in_index | Column_name      |
    -- +--------+------------+----------------+--------------+------------------+
    -- | libros | 0          | PRIMARY        | 1            | id_libro         |
    -- | libros | 0          | isbn           | 1            | isbn             |
    -- | libros | 1          | idx_titulo     | 1            | titulo           |
    -- | libros | 1          | idx_autor_a√±o  | 1            | id_autor         |
    -- | libros | 1          | idx_autor_a√±o  | 2            | a√±o_publicacion  |
    -- +--------+------------+----------------+--------------+------------------+</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 11 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 11: Query Compleja - Informe de Pr√©stamos</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Genera un informe que muestre: socios con pr√©stamos vencidos (no devueltos
                            y pasada la fecha prevista), t√≠tulo del libro, d√≠as de retraso, y email del socio para contactar.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">SELECT
        s.nombre AS socio,
        s.email,
        s.telefono,
        l.titulo AS libro_prestado,
        p.fecha_prestamo,
        p.fecha_devolucion_prevista,
        DATEDIFF(CURDATE(), p.fecha_devolucion_prevista) AS dias_retraso
    FROM prestamos p
    INNER JOIN socios s ON p.id_socio = s.id_socio
    INNER JOIN libros l ON p.id_libro = l.id_libro
    WHERE p.fecha_devolucion_real IS NULL  -- No devuelto a√∫n
    AND p.fecha_devolucion_prevista < CURDATE()  -- Fecha prevista ya pas√≥
    ORDER BY dias_retraso DESC;

    -- Resultado (ejemplo si Ana tiene libro vencido):
    -- +--------------+-------------------------+-----------+--------------------------+----------------+--------------------------+--------------+
    -- | socio        | email                   | telefono  | libro_prestado           | fecha_prestamo | fecha_devolucion_prevista| dias_retraso |
    -- +--------------+-------------------------+-----------+--------------------------+----------------+--------------------------+--------------+
    -- | Ana Mart√≠nez | ana.martinez@email.com  | 666111222 | La casa de los esp√≠ritus | 2024-11-01     | 2024-11-15               | 3            |
    -- +--------------+-------------------------+-----------+--------------------------+----------------+--------------------------+--------------+

    -- Explicaci√≥n:
    -- - INNER JOIN conecta pr√©stamos, socios y libros
    -- - WHERE filtra: sin devolver Y fecha prevista pasada
    -- - DATEDIFF calcula d√≠as de retraso
    -- - ORDER BY prioriza retrasos mayores</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 12 -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 12: Subconsulta Correlacionada - Socios Activos</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Encuentra socios que hayan hecho al menos 2 pr√©stamos en total (incluyendo devueltos).
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n con Subconsulta</span>
                            </div>
                            <pre><code class="language-sql">-- Opci√≥n 1: Subconsulta en WHERE
    SELECT nombre, email
    FROM socios s
    WHERE (
        SELECT COUNT(*)
        FROM prestamos p
        WHERE p.id_socio = s.id_socio
    ) >= 2;

    -- Opci√≥n 2: JOIN + GROUP BY + HAVING (m√°s eficiente)
    SELECT
        s.nombre,
        s.email,
        COUNT(p.id_prestamo) AS total_prestamos
    FROM socios s
    INNER JOIN prestamos p ON s.id_socio = p.id_socio
    GROUP BY s.id_socio, s.nombre, s.email
    HAVING COUNT(p.id_prestamo) >= 2
    ORDER BY total_prestamos DESC;

    -- Resultado (si agregamos m√°s datos):
    -- +--------------+-------------------------+-----------------+
    -- | nombre       | email                   | total_prestamos |
    -- +--------------+-------------------------+-----------------+
    -- | Ana Mart√≠nez | ana.martinez@email.com  | 3               |
    -- | Carlos Ruiz  | carlos.ruiz@email.com   | 2               |
    -- +--------------+-------------------------+-----------------+</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 13 (BONUS) -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 13 (Bonus): Trigger y Procedimiento Almacenado</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Crea un procedimiento almacenado para registrar pr√©stamos y un trigger que
                            actualice autom√°ticamente la disponibilidad del libro.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Soluci√≥n</span>
                            </div>
                            <pre><code class="language-sql">-- Crear procedimiento almacenado para registrar pr√©stamo
    DELIMITER //

    CREATE PROCEDURE registrar_prestamo(
        IN p_id_libro INT,
        IN p_id_socio INT,
        IN p_dias_plazo INT
    )
    BEGIN
        DECLARE libro_disponible BOOLEAN;

        -- Verificar disponibilidad
        SELECT disponible INTO libro_disponible
        FROM libros
        WHERE id_libro = p_id_libro;

        IF libro_disponible = FALSE THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Libro no disponible';
        END IF;

        -- Registrar pr√©stamo en transacci√≥n
        START TRANSACTION;

        INSERT INTO prestamos (id_libro, id_socio, fecha_prestamo, fecha_devolucion_prevista)
        VALUES (p_id_libro, p_id_socio, CURDATE(), DATE_ADD(CURDATE(), INTERVAL p_dias_plazo DAY));

        UPDATE libros SET disponible = FALSE WHERE id_libro = p_id_libro;

        COMMIT;
    END //

    DELIMITER ;

    -- Crear trigger para actualizar disponibilidad al devolver
    DELIMITER //

    CREATE TRIGGER after_devolucion
    AFTER UPDATE ON prestamos
    FOR EACH ROW
    BEGIN
        -- Si se actualiza fecha_devolucion_real (estaba NULL, ahora tiene valor)
        IF OLD.fecha_devolucion_real IS NULL AND NEW.fecha_devolucion_real IS NOT NULL THEN
            UPDATE libros SET disponible = TRUE WHERE id_libro = NEW.id_libro;
        END IF;
    END //

    DELIMITER ;

    -- Usar el procedimiento
    CALL registrar_prestamo(1, 2, 14);  -- Libro 1 a socio 2 por 14 d√≠as

    -- Verificar
    SELECT * FROM prestamos WHERE id_prestamo = LAST_INSERT_ID();
    SELECT disponible FROM libros WHERE id_libro = 1;  -- FALSE

    -- Simular devoluci√≥n (activa el trigger)
    UPDATE prestamos
    SET fecha_devolucion_real = CURDATE()
    WHERE id_prestamo = LAST_INSERT_ID();

    -- Verificar trigger funcion√≥
    SELECT disponible FROM libros WHERE id_libro = 1;  -- TRUE ‚úÖ</code></pre>
                        </div>
                    </article>

                    <!-- Ejercicio 14 (BONUS) -->
                    <article class="topic">
                        <h3 class="topic-title">Ejercicio 14 (Bonus): Optimizaci√≥n Completa</h3>
                        <p class="topic-description">
                            <strong>Enunciado:</strong> Optimiza la siguiente query lenta que lista pr√©stamos con informaci√≥n completa.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Query Inicial (LENTA)</span>
                            </div>
                            <pre><code class="language-sql">-- Query sin optimizar
    SELECT
        s.nombre,
        (SELECT titulo FROM libros WHERE id_libro = p.id_libro) AS libro,
        (SELECT nombre FROM autores WHERE id_autor = (
            SELECT id_autor FROM libros WHERE id_libro = p.id_libro
        )) AS autor,
        p.fecha_prestamo
    FROM prestamos p, socios s
    WHERE p.id_socio = s.id_socio;

    -- PROBLEMAS:
    -- ‚ùå Subconsultas correlacionadas en SELECT (N+1 queries)
    -- ‚ùå Sintaxis antigua de JOIN (coma en FROM)
    -- ‚ùå Subconsulta anidada para autor</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Query Optimizada</span>
                            </div>
                            <pre><code class="language-sql">-- Query optimizada con JOINs
    SELECT
        s.nombre AS socio,
        l.titulo AS libro,
        a.nombre AS autor,
        p.fecha_prestamo
    FROM prestamos p
    INNER JOIN socios s ON p.id_socio = s.id_socio
    INNER JOIN libros l ON p.id_libro = l.id_libro
    INNER JOIN autores a ON l.id_autor = a.id_autor;

    -- MEJORAS:
    -- ‚úÖ Una sola query en vez de N+1
    -- ‚úÖ JOINs expl√≠citos (INNER JOIN)
    -- ‚úÖ Sin subconsultas
    -- ‚úÖ MySQL puede usar √≠ndices en FKs

    -- Analizar con EXPLAIN
    EXPLAIN SELECT ...  -- Verifica que usa √≠ndices en todas las FKs

    -- Crear √≠ndices si faltan:
    CREATE INDEX idx_id_socio ON prestamos(id_socio);
    CREATE INDEX idx_id_libro ON prestamos(id_libro);
    CREATE INDEX idx_id_autor ON libros(id_autor);

    -- Resultado: Query 10x-100x m√°s r√°pida</code></pre>
                        </div>
                    </article>

                    <!-- Resumen Final -->
                    <div class="tip-box">
                        <div class="tip-title">üéØ Resumen de Ejercicios</div>
                        <ul class="tip-list">
                            <li><strong>Ejercicio 1-2:</strong> CREATE TABLE, INSERT, SELECT b√°sico con WHERE/ORDER BY</li>
                            <li><strong>Ejercicio 3-4:</strong> INNER JOIN y LEFT JOIN para relacionar tablas</li>
                            <li><strong>Ejercicio 5:</strong> GROUP BY con funciones agregadas (COUNT, MAX)</li>
                            <li><strong>Ejercicio 6:</strong> Subconsultas en WHERE para comparaciones</li>
                            <li><strong>Ejercicio 7:</strong> UPDATE para modificar datos relacionados</li>
                            <li><strong>Ejercicio 8:</strong> Transacciones con START TRANSACTION, COMMIT</li>
                            <li><strong>Ejercicio 9:</strong> Normalizaci√≥n de tabla desnormalizada a 3FN</li>
                            <li><strong>Ejercicio 10:</strong> Crear √≠ndices y optimizar con EXPLAIN</li>
                            <li><strong>Ejercicio 11:</strong> Query compleja con m√∫ltiples condiciones y c√°lculos</li>
                            <li><strong>Ejercicio 12:</strong> Subconsultas correlacionadas y GROUP BY + HAVING</li>
                            <li><strong>Ejercicio 13:</strong> Procedimientos almacenados y triggers (avanzado)</li>
                            <li><strong>Ejercicio 14:</strong> Optimizaci√≥n completa de query lenta</li>
                        </ul>
                    </div>
                </section>
            </div>
        </div>
    </main> 
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3 class="footer-title"><span class="logo-code">Code</span><span class="logo-dam">DAM</span></h3>
                    <p class="footer-description">Apuntes completos y gratuitos para estudiantes de DAM.</p>
                </div>
                <div class="footer-section">
                    <h4 class="footer-subtitle">1¬∫ DAM</h4>
                    <ul class="footer-links">
                        <li><a href="programacion.html">Programaci√≥n</a></li>
                        <li><a href="bases-datos.html">Bases de Datos</a></li>
                        <li><a href="lenguajes-marcas.html">Lenguajes de Marcas</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4 class="footer-subtitle">Enlaces</h4>
                    <ul class="footer-links">
                        <li><a href="../../index.html">Inicio</a></li>
                        <li><a href="../buscar.html">Buscador</a></li>
                        <li><a href="../ingles/index.html">Ingl√©s T√©cnico</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 CodeDAM. Contenido educativo gratuito.</p>
            </div>
        </div>
    </footer>

    <script src="../../js/main.js"></script>

    <!-- Scripts -->
    <script src="../../js/features.js"></script>
    <script src="../../js/astro-bot.js"></script>

    <!-- Prism.js Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
    // Auto-generate TOC
    document.addEventListener('DOMContentLoaded', () => {
        const toc = document.querySelector('.toc ul');
        const sections = document.querySelectorAll('.content-section h2');
        
        sections.forEach((section, index) => {
            const id = `section-${index}`;
            section.id = id;
            
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = `#${id}`;
            a.textContent = section.textContent;
            li.appendChild(a);
            toc.appendChild(li);
        });

        // Reading progress
        const progressBar = document.createElement('div');
        progressBar.className = 'reading-progress';
        document.body.prepend(progressBar);

        window.addEventListener('scroll', () => {
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight - windowHeight;
            const scrolled = window.scrollY;
            const progress = (scrolled / documentHeight) * 100;
            progressBar.style.width = progress + '%';
        });

        // Back to top button
        const backToTop = document.createElement('div');
        backToTop.className = 'back-to-top';
        backToTop.innerHTML = '‚Üë';
        document.body.appendChild(backToTop);

        window.addEventListener('scroll', () => {
            if (window.scrollY > 300) {
                backToTop.classList.add('visible');
            } else {
                backToTop.classList.remove('visible');
            }
        });

        backToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    });
    </script>
</body>
</html>